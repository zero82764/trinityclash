<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trinity Clash</title>
    <link rel="manifest" href="manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Trinity Clash">
    <meta name="apple-mobile-web-app-title" content="Trinity Clash">
    <meta name="theme-color" content="#2d2d2d">
    <meta name="msapplication-navbutton-color" content="#2d2d2d">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="msapplication-starturl" content="/">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=MedievalSharp&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            background-color: #2d2d2d; /* Darker background */
            background-image:
                radial-gradient(circle at center, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0) 60%),
                linear-gradient(45deg, rgba(0,0,0,0.2) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.2) 75%),
                linear-gradient(45deg, rgba(0,0,0,0.2) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.2) 75%);
            background-size: 100% 100%, 60px 60px, 60px 60px;
            background-position: 0 0, 0 0, 30px 30px;
            font-family: 'MedievalSharp', cursive;
            overflow: hidden; /* Prevent scrolling */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // ===================================
        //  🎨 1. CONFIGURATION & CONSTANTS
        // ===================================
        const COLORS = {
            background: '#2d2d2d',
            text: '#EAE0C8',
            cardBorder: '#1a1a1a',
            might: '#9E2B25',   // Deep Red
            finesse: '#00695C', // Teal Green
            magic: '#4A5D9A',   // Royal Blue
            accent: '#FFD700', // Brighter Gold
            disabled: '#424242',
            button: { start: '#8D6E63', end: '#5D4037' }, // Wood Brown Gradient
            buttonHover: { start: '#A1887F', end: '#795548' },
            buttonBorder: '#3E2723', // Darker Wood
            damage: '#FF7043', // Orange-Red for damage
            ability: '#4FC3F7', // Light Blue for abilities
            info: '#BDBDBD'     // Gray for general info
        };

        const HEROES = [
            // Might Heroes
            { id: 0, name: 'Sir Reginald', type: 'Might', hp: 10, ap: 4, abilityId: 'lastStand',
              description: 'Last Stand: Survives one KO with 1 HP.',
              detailedDescription: 'Last Stand: If knocked out, survives with 1 HP. This ability can only activate once per game.' },
            { id: 1, name: 'Grak the Crusher', type: 'Might', hp: 8, ap: 6, abilityId: 'crush',
              description: 'Crush: Attacks ignore damage reduction.',
              detailedDescription: 'Crush: His attacks ignore all damage reduction effects, including the halving effect from Trinity Advantage.' },
            { id: 6, name: 'Boro the Bulwark', type: 'Might', hp: 10, ap: 4, abilityId: 'tank',
              description: 'Tank: Absorbs all damage for allies.',
              detailedDescription: 'Tank: Boro absorbs all damage for his allies. All single-target attacks and abilities will hit Boro instead of their original target.' },
            { id: 9, name: 'Skeleton Warrior', type: 'Might', hp: 10, ap: 4, abilityId: null,
              description: 'A sturdy and reliable frontline soldier.',
              detailedDescription: 'A sturdy and reliable frontline soldier with no special abilities.' },
            { id: 12, name: 'Goblin Brawler', type: 'Might', hp: 9, ap: 5, abilityId: 'mobRule',
              description: 'Mob Rule: +1 AP per other living Goblin.',
              detailedDescription: 'Mob Rule: Gains +1 Attack Power for each other living Goblin ally on the board.' },
            { id: 15, name: 'Karn the Barbed', type: 'Might', hp: 9, ap: 5, abilityId: 'bleed',
              description: 'Bleed: Hits cause stacking damage over time.',
              detailedDescription: 'Bleed: A successful hit causes the target to take 1 damage at the start of each round. This effect can stack up to 3 times.' },
            { id: 23, name: 'Goblin Brute', type: 'Might', hp: 8, ap: 6, abilityId: 'toughness',
              description: 'Toughness: +1 Max HP per other living Goblin.',
              detailedDescription: 'Toughness: Gains +1 maximum HP for each other living Goblin ally on the board at the start of the game.' },

            // Finesse Heroes
            { id: 2, name: 'Vex', type: 'Finesse', hp: 7, ap: 7, abilityId: 'firstStrike',
              description: 'First Strike: Attacks first, avoids damage on KO.',
              detailedDescription: 'First Strike: Attacks first. If she defeats the opponent with her attack, she takes no counter-attack damage.' },
            { id: 3, name: 'Kaelen', type: 'Finesse', hp: 7, ap: 7, abilityId: 'longBow',
              description: 'Long Bow: Deals 2 damage every other round.',
              detailedDescription: 'Long Bow: At the start of every even-numbered round (2, 4, 6...), Kaelen deals 2 damage to a random enemy hero.' },
            { id: 7, name: 'Lyra Nightwind', type: 'Finesse', hp: 8, ap: 6, abilityId: 'smokeBomb',
              description: 'Smoke Bomb: The first attack misses.',
              detailedDescription: 'Smoke Bomb: The first time Lyra would be dealt damage from an attack each game, that damage is ignored.' },
            { id: 10, name: 'Skeleton Archer', type: 'Finesse', hp: 7, ap: 7, abilityId: null,
              description: 'A balanced archer with no special tricks.',
              detailedDescription: 'A balanced archer with no special abilities.' },
            { id: 13, name: 'Goblin Cutpurse', type: 'Finesse', hp: 7, ap: 7, abilityId: 'ambush',
              description: 'Ambush: Deals 2 damage from the bench.',
              detailedDescription: 'Ambush: When another one of your heroes clashes, this hero deals 2 damage to the clashing enemy from the bench.' },
            { id: 16, name: 'Seraphina', type: 'Finesse', hp: 7, ap: 7, abilityId: 'riposte',
              description: 'Riposte: Damages heroes who use abilities on her.',
              detailedDescription: 'Riposte: When hit by an enemy ability while not currently in a clash, deals 2 damage back to the ability\'s caster.' },
            { id: 20, name: 'Zephyr, the Tempest', type: 'Finesse', hp: 8, ap: 6, abilityId: 'galeForce',
              description: 'Gale Force: Swaps clashing enemy with a benched one.',
              detailedDescription: 'Gale Force: Before this hero clashes, it swaps the opposing hero with a random one from their bench.' },
            { id: 21, name: 'Goblin Scout', type: 'Finesse', hp: 7, ap: 7, abilityId: 'evasion',
              description: 'Evasion: Dodges the first attack once.',
              detailedDescription: 'Evasion: The first time this hero is attacked by any source each game, it takes no damage.' },
            { id: 22, name: 'Goblin Assassin', type: 'Finesse', hp: 6, ap: 8, abilityId: 'opportunist',
              description: 'Opportunist: +3 damage to weaker foes.',
              detailedDescription: 'Opportunist: Deals +3 damage if the opponent has less current HP than this hero.' },

            // Magic Heroes
            { id: 4, name: 'Elara', type: 'Magic', hp: 6, ap: 8, abilityId: 'soulSiphon',
              description: 'Soul Siphon: Gains max HP of first KO\'d foe.',
              detailedDescription: 'Soul Siphon: The first time Elara defeats an enemy, her current and maximum HP are increased by the defeated enemy\'s maximum HP.' },
            { id: 5, name: 'Zoltan', type: 'Magic', hp: 5, ap: 9, abilityId: 'overload',
              description: 'Overload: 50% chance for 4 splash damage.',
              detailedDescription: 'Overload: After clashing, has a 50% chance to deal 4 damage to another random hero on the board (friend or foe).' },
            { id: 8, name: 'Master Theron', type: 'Magic', hp: 7, ap: 7, abilityId: 'fireball',
              description: 'Fireball: On round 5, hits all enemies.',
              detailedDescription: 'Fireball: At the start of round 5, deals 5 damage to all living enemy heroes.' },
            { id: 11, name: 'Skeleton Mage', type: 'Magic', hp: 4, ap: 10, abilityId: null,
              description: 'A frail but powerful spellcaster.',
              detailedDescription: 'A frail but powerful spellcaster with no special abilities.' },
            { id: 14, name: 'Goblin Bomber', type: 'Magic', hp: 4, ap: 10, abilityId: 'unstableConcoction',
              description: 'Unstable Concoction: Explodes on advantage.',
              detailedDescription: 'Unstable Concoction: If this hero has a type advantage in a clash, it explodes, dealing 3 damage to all living enemies.' },
            { id: 17, name: 'Malachi the Gambler', type: 'Magic', hp: 5, ap: 0, abilityId: 'chaosBolt',
              description: 'Chaos Bolt: Deals 6-18 true damage.',
              detailedDescription: 'Chaos Bolt: Deals a random amount of damage from 6 to 18. This damage is \'true\' and cannot be reduced by any means.' },
            { id: 18, name: 'Gyrion the Trickster', type: 'Magic', hp: 6, ap: 8, abilityId: 'madScramble',
              description: 'Mad Scramble: Swaps two random heroes.',
              detailedDescription: 'Mad Scramble: After this hero attacks, it swaps the positions of two random heroes on the entire board (excluding itself and its clash opponent).' },
            { id: 19, name: 'Jester of Chaos', type: 'Magic', hp: 7, ap: 7, abilityId: 'boonOfBedlam',
              description: 'Boon of Bedlam: Bolt leaps to heal or harm.',
              detailedDescription: 'Boon of Bedlam: After this hero attacks, a bolt of energy leaps to another random hero (friend or foe), either dealing 5 damage or healing 5 HP.' }
        ];

        const BOSSES = [
            { id: 100, name: 'Minotaur', type: 'Might', hp: 50, ap: 5, abilities: ['cleave', 'ram', 'intimidation'], description: 'A fearsome beast with devastating attacks.' }
        ];

        const TRAITS = ['Aggressive', 'Cautious', 'Pillager'];

        const SLAYER_TITLES = {
            Might: 'Giant-Slayer',
            Finesse: 'Swift-Slayer',
            Magic: 'Mage-Slayer'
        };

        const HUNTER_TRAITS = {
            Might: 'Might-Hunter',
            Finesse: 'Finesse-Hunter',
            Magic: 'Magic-Hunter'
        };

        const BUILDING_COSTS = {
            barracks: {
                1: { gold: 50, stone: 25, dust: 0 },
                2: { gold: 150, stone: 75, dust: 0 },
                3: { gold: 300, stone: 150, dust: 25 }
            },
            thievesGuild: {
                1: { gold: 75, stone: 0, dust: 10 },
                2: { gold: 200, stone: 25, dust: 30 },
                3: { gold: 400, stone: 75, dust: 60 }
            },
            wizardsTower: {
                1: { gold: 25, stone: 50, dust: 20 },
                2: { gold: 75, stone: 150, dust: 60 },
                3: { gold: 150, stone: 300, dust: 120 }
            }
        };

        const TERRITORIES = [
            { territoryId: 1, name: 'Whispering Woods', resourceType: 'gold', resourceValue: 50, controllingRivalId: null },
            { territoryId: 2, name: 'Stonefall Pass', resourceType: 'stone', resourceValue: 25, controllingRivalId: null },
            { territoryId: 3, name: 'Dustbowl Oasis', resourceType: 'dust', resourceValue: 10, controllingRivalId: null }
        ];

        const CAMPAIGN_MAP_DATA = {
            // We use percentages for x/y so it scales on different screen sizes
            nodes: [
                { id: 1, name: 'Your Citadel', x: 15, y: 50, type: 'citadel', owner: 'player' },
                { id: 2, name: 'Whispering Woods', x: 25, y: 35, type: 'standard', resource: 'lumber' },
                { id: 3, name: 'Stone Quarry', x: 28, y: 65, type: 'standard', resource: 'stone' },
                { id: 4, name: 'The Twin Peaks', x: 40, y: 30, type: 'elite', resource: 'gold' },
                { id: 5, name: 'The Sunken Fort', x: 45, y: 70, type: 'fortress', resource: 'gold' },
                { id: 6, name: 'The Arcane Ruin', x: 55, y: 50, type: 'standard', resource: 'dust' }
                // ... add more nodes as needed
            ],
            connections: [
                [1, 2], // Path from Your Citadel to Whispering Woods
                [1, 3], // Path from Your Citadel to Stone Quarry
                [2, 4],
                [3, 5],
                [4, 6],
                [5, 6]
            ]
        };

        // ===================================
        //  CAMPAIGN DATA STRUCTURES
        // ===================================
        class Rival {
            constructor(baseHero, uniqueId, controlledTerritoryId, title = '', traits = [], history = []) {
                // Copy all properties from the base hero
                Object.assign(this, baseHero);

                // Add additional Rival-specific properties
                this.uniqueId = uniqueId;
                this.title = title;
                this.level = 1; // Starts at 1
                this.traits = traits;
                this.history = history;
                this.controlledTerritoryId = controlledTerritoryId;
            }
        }

        class Territory {
            constructor(territoryId, name, resourceType, resourceValue, controllingRivalId) {
                this.territoryId = territoryId;
                this.name = name;
                this.resourceType = resourceType;
                this.resourceValue = resourceValue;
                this.controllingRivalId = controllingRivalId;
            }
        }

        // ===================================
        //  HELPER FUNCTIONS
        // ===================================
        function arraysEqual(a, b) {
            if (a === b) return true;
            if (a == null || b == null) return false;
            if (a.length !== b.length) return false;

            for (let i = 0; i < a.length; ++i) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }

        // ===================================
        //  ⚔️ 2. GAME CLASS
        // ===================================
        class Game {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');

                this.scale = 1;
                this.baseWidth = 1920;
                this.baseHeight = 1080;
                this.baseCardWidth = 180;
                this.baseCardHeight = 260;

                this.cardHitboxes = { player1: [], player2: [], selection: [] };
                this.campaignMapHitboxes = [];
                this.buttonHitboxes = {};
                this.mousePos = { x: 0, y: 0 };
                this.heroImages = {};
                this.logoImage = null;
                this.imagesLoaded = false;
                this.loadedImageCount = 0;
                // All heroes, all bosses, and one logo
                this.totalImages = HEROES.length + BOSSES.length + 1;


                this.state = this.getInitialState();

                this.init();
            }

            // -----------------------------------
            //  Initialization
            // -----------------------------------
            init() {
                this.resizeCanvas();
                this.loadAssets();
                window.addEventListener('resize', () => this.resizeCanvas());
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('wheel', (e) => this.handleMouseWheel(e), { passive: false });
                this.gameLoop();
            }

            loadAssets() {
                console.log("Loading assets...");

                const onFinish = (name) => {
                    this.loadedImageCount++;
                    console.log(`Loaded asset ${this.loadedImageCount}/${this.totalImages}: ${name}`);
                    if (this.loadedImageCount === this.totalImages) {
                        console.log("All assets loaded.");
                        this.imagesLoaded = true;
                    }
                };

                // Load Logo
                const logoImg = new Image();
                logoImg.crossOrigin = "Anonymous"; // Needed for cross-domain images on canvas
                logoImg.src = 'https://i.imgur.com/DhR6stR.png';
                logoImg.onload = () => {
                    this.logoImage = logoImg;
                    onFinish('logo');
                };
                logoImg.onerror = () => {
                    console.error("Failed to load logo image.");
                    onFinish('logo'); // Still count it as "finished" to not stall the loading screen
                };


                // Load Hero Images
                const allCharacters = [...HEROES, ...BOSSES];
                if (allCharacters.length === 0 && this.totalImages === 1) { // Only logo to load
                    this.imagesLoaded = true;
                    return;
                }

                allCharacters.forEach(hero => {
                    const img = new Image();
                    const imageName = hero.name.toLowerCase().replace(/,/g, '').replace(/ /g, '_');
                    img.src = `images/${imageName}.png`;

                    img.onload = () => {
                        this.heroImages[hero.id] = img;
                        onFinish(hero.name);
                    };
                    img.onerror = () => {
                        // Don't assign a broken image, just mark as loaded
                        onFinish(hero.name);
                    };
                });
            }

            getInitialState() {
                return {
                    gamePhase: 'mainMenu',
                    difficulty: 'normal',
                    teamSize: 3,
                    player1Team: [],
                    player2Team: [],
                    player1Selection: null,
                    player2Selection: null,
                    winner: null,
                    isClashing: false,
                    pendingClash: null,
                    animation: null,
                    impactAnimation: null,
                    fireballAnimation: null,
                    overloadAnimation: null,
                    round: 1,
                    heroViewerIndex: 0,
                    practiceSelectionState: 'player',
                    hoveredHero: null,
                    abilityAnimations: [],
                    battleLog: [[]],
                    battleLogScrollOffset: 0,
                    confettiParticles: [],
                    bossActiveAbility: null,
                    nextUUID: 1, // Unique ID counter for hero instances
                    isCampaignBattle: false,
                    vengeanceMode: false,
                    vengeanceSurvivors: null,
                    citadel: {
                        resources: { gold: 100, stone: 50, dust: 20 },
                        buildings: {
                            barracks: { level: 1, name: 'Barracks' },
                            thievesGuild: { level: 0, name: 'Thieves\' Guild' },
                            wizardsTower: { level: 0, name: 'Wizard\'s Tower' }
                        },
                        unlockedHeroes: [],
                        assignedHeroes: {}
                    },
                    campaignState: null, // This will hold the live campaign data
                    hoveredNode: null // To track which map node the mouse is over
                };
            }

            resetGame() {
                this.state = this.getInitialState();
                this.log([{ text: 'Welcome! Select a hero to begin.', color: COLORS.info }]);
            }

            upgradeBuilding(buildingName) {
                const building = this.state.citadel.buildings[buildingName];
                if (!building) {
                    console.error(`Building ${buildingName} not found in citadel.`);
                    return false;
                }

                const currentLevel = building.level;
                const nextLevel = currentLevel + 1;
                const costs = BUILDING_COSTS[buildingName];

                if (!costs || !costs[nextLevel]) {
                    this.log([{ text: `The ${building.name} is already at its maximum level!`, color: COLORS.info }]);
                    return false;
                }

                const cost = costs[nextLevel];
                const playerResources = this.state.citadel.resources;

                // Check if player can afford the upgrade
                for (const resource in cost) {
                    if (playerResources[resource] < cost[resource]) {
                        this.log([
                            { text: 'Not enough resources to upgrade the ', color: COLORS.damage },
                            { text: building.name, color: COLORS.accent },
                            { text: '.', color: COLORS.damage }
                        ]);
                        return false;
                    }
                }

                // Deduct resources
                for (const resource in cost) {
                    playerResources[resource] -= cost[resource];
                }

                // Upgrade building
                building.level = nextLevel;

                this.log([
                    { text: `The ${building.name} has been upgraded to Level ${nextLevel}!`, color: COLORS.accent }
                ]);

                return true;
            }

            generateRival(heroId, territoryId) {
                const baseHero = HEROES.find(h => h.id === heroId);
                if (!baseHero) {
                    console.error(`Hero with id ${heroId} not found.`);
                    return null;
                }

                const randomTrait = TRAITS[Math.floor(Math.random() * TRAITS.length)];
                const uniqueId = this.state.nextUUID++;

                const newRival = new Rival(
                    JSON.parse(JSON.stringify(baseHero)), // Use a deep copy of the hero
                    uniqueId,
                    territoryId,
                    '',            // Default title
                    [randomTrait]  // Trait list
                );

                return newRival;
            }

            handleRivalPromotion(rival, playerHeroDefeated) {
                rival.level++;
                rival.history.push(`Defeated ${playerHeroDefeated.name} and was promoted to Level ${rival.level}.`);

                const defeatedHeroType = playerHeroDefeated.type;
                const newTitle = SLAYER_TITLES[defeatedHeroType];
                const newTrait = HUNTER_TRAITS[defeatedHeroType];

                if (newTitle) {
                    rival.title = newTitle;
                }
                if (newTrait && !rival.traits.includes(newTrait)) {
                    rival.traits.push(newTrait);
                }

                this.log([
                    { text: rival.name, color: COLORS[rival.type.toLowerCase()] },
                    { text: ` has been promoted! They are now known as ${rival.name}, ${rival.title}.`, color: COLORS.accent }
                ]);
            }

            collectTerritoryRewards(territory) {
                if (!territory || !territory.resourceType || !territory.resourceValue) {
                    console.error("Invalid territory data for collecting rewards.");
                    return;
                }

                const { resourceType, resourceValue } = territory;
                const playerResources = this.state.citadel.resources;

                if (playerResources.hasOwnProperty(resourceType)) {
                    playerResources[resourceType] += resourceValue;
                    this.log([
                        { text: `You collected `, color: COLORS.info },
                        { text: `${resourceValue} ${resourceType}`, color: COLORS.accent },
                        { text: ` from ${territory.name}!`, color: COLORS.info }
                    ]);
                } else {
                    console.error(`Unknown resource type: ${resourceType}`);
                }
            }

            initializeTeam(team, teamKey) {
                team.forEach(hero => {
                    hero.statusEffects = [];
                    hero.teamKey = teamKey;
                    hero.evasionUsed = false; // For Goblin Scout

                    // Calculate Max HP for abilities like Toughness
                    let maxHp = hero.hp;
                    if (hero.abilityId === 'toughness') {
                        maxHp += team.filter(h => h.uuid !== hero.uuid && h.name.includes('Goblin')).length;
                    }
                    hero.maxHp = maxHp;
                    hero.hp = hero.maxHp;
                });
            }

            startBossBattle() {
                this.state.teamSize = 5;
                if (this.state.player1Team.length !== this.state.teamSize) {
                    this.state.gamePhase = 'heroSelection';
                    return;
                }
                this.state.player2Team = [JSON.parse(JSON.stringify(BOSSES[0]))];
                this.state.player2Team[0].uuid = this.state.nextUUID++;

                this.initializeTeam(this.state.player1Team, 'player1');
                this.initializeTeam(this.state.player2Team, 'player2');
                this.state.gamePhase = 'bossBattle';
                this.log([{ text: 'BOSS BATTLE! The Minotaur appears!', color: COLORS.might }]);
                this.log([{ text: 'Select a hero to face the beast.', color: COLORS.info }]);
            }

            startGame(isPractice = false) {
                if (this.state.player1Team.length !== this.state.teamSize) return;

                if (!isPractice) {
                    const deepCopyHeroes = JSON.parse(JSON.stringify(HEROES));

                    if (this.state.difficulty === 'easy') {
                        this.state.player2Team = deepCopyHeroes.filter(hero =>
                            hero.name.includes('Skeleton')
                        ).slice(0, this.state.teamSize);
                    } else {
                        const playerHeroIds = this.state.player1Team.map(h => h.id);
                        let remainingHeroes = deepCopyHeroes.filter(hero => !playerHeroIds.includes(hero.id));

                        if (this.state.difficulty === 'expert') {
                            const team = [];
                            const pickedIds = new Set();
                            const getPowerScore = (hero) => hero.hp + hero.ap;

                            // --- Synergy Check: Goblins ---
                            const availableGoblins = remainingHeroes.filter(h => h.name.includes('Goblin'));
                            if (availableGoblins.length >= 2 && Math.random() < 0.6) {
                                availableGoblins.forEach(goblin => {
                                    if (team.length < this.state.teamSize) {
                                        team.push(goblin);
                                        pickedIds.add(goblin.id);
                                    }
                                });
                            }

                            // --- Main Picking Logic ---
                            if (team.length < this.state.teamSize) { // Only run if synergy didn't fill the team
                                const playerTypes = { Might: 0, Finesse: 0, Magic: 0 };
                                this.state.player1Team.forEach(hero => playerTypes[hero.type]++);
                                const counterType = { Might: 'Magic', Finesse: 'Might', Magic: 'Finesse' };
                                const typePriority = Object.keys(playerTypes)
                                    .sort((a, b) => playerTypes[b] - playerTypes[a])
                                    .map(type => counterType[type]);

                                const pickStrongestFromType = (type, excludeIds) => {
                                    const available = remainingHeroes.filter(h => h.type === type && !excludeIds.has(h.id));
                                    if (available.length === 0) return null;
                                    available.sort((a, b) => getPowerScore(b) - getPowerScore(a));
                                    return available[0];
                                };

                                // 1. Pick 1 or 2 initial counters
                                const numCounters = this.state.teamSize === 5 ? 2 : 1;
                                for (let i = 0; i < numCounters; i++) {
                                    if (team.length < this.state.teamSize) {
                                        let counterPick = null;
                                        // Find the best available counter based on type priority
                                        for (const type of typePriority) {
                                            counterPick = pickStrongestFromType(type, pickedIds);
                                            if (counterPick) break;
                                        }
                                        if (counterPick) {
                                            team.push(counterPick);
                                            pickedIds.add(counterPick.id);
                                        }
                                    }
                                }

                                // 2. Fill remaining slots with the best overall heroes
                                while (team.length < this.state.teamSize) {
                                    const remainingPool = remainingHeroes.filter(h => !pickedIds.has(h.id));
                                    if (remainingPool.length === 0) break;

                                    remainingPool.sort((a, b) => getPowerScore(b) - getPowerScore(a));
                                    const bestOverall = remainingPool[0];

                                    if (bestOverall) {
                                        team.push(bestOverall);
                                        pickedIds.add(bestOverall.id);
                                    }
                                }
                            }
                            this.state.player2Team = team;
                        } else if (this.state.difficulty === 'impossible') {
                            this.state.vengeanceMode = false;
                            const playerTeamIds = this.state.player1Team.map(h => h.id).sort();
                            try {
                                const lossHistory = JSON.parse(localStorage.getItem('trinityClashLosses') || '[]');
                                const pastDefeat = lossHistory.find(loss => arraysEqual(loss.defeatedBy, playerTeamIds));
                                if (pastDefeat) {
                                    this.state.vengeanceMode = true;
                                    console.log("Impossible AI: Vengeance mode activated against this team!");
                                    if (pastDefeat.survivors) {
                                        this.state.vengeanceSurvivors = pastDefeat.survivors;
                                        console.log("Impossible AI: Prioritizing survivors from last defeat:", pastDefeat.survivors);
                                    }
                                }
                            } catch (e) {
                                console.error("Could not parse loss history.", e);
                            }

                            console.log("Impossible AI: Starting team selection.");
                            const team = [];
                            const pickedIds = new Set();
                            const getPowerScore = (hero) => {
                                let score = hero.hp + hero.ap;
                                if (['firstStrike', 'soulSiphon', 'crush', 'unstableConcoction', 'galeForce'].includes(hero.abilityId)) score += 5;
                                if (hero.abilityId === 'tank') score += 10;

                                if (this.state.vengeanceMode) {
                                    const counterBonus = 20; // A large bonus for a counter-pick
                                    const counterType = { Might: 'Magic', Finesse: 'Might', Magic: 'Finesse' };
                                    this.state.player1Team.forEach(playerHero => {
                                        if (hero.type === counterType[playerHero.type]) {
                                            score += counterBonus;
                                            console.log(`Vengeance mode: ${hero.name} gets +${counterBonus} for countering ${playerHero.name}`);
                                        }
                                    });
                                }

                                return score;
                            };

                            console.log("Impossible AI: Analyzing player team.");
                            const playerTypes = { Might: 0, Finesse: 0, Magic: 0 };
                            this.state.player1Team.forEach(hero => playerTypes[hero.type]++);
                            const counterType = { Might: 'Magic', Finesse: 'Might', Magic: 'Finesse' };

                            console.log("Impossible AI: Checking for Goblin synergy.");
                            const availableGoblins = remainingHeroes.filter(h => h.name.includes('Goblin'));
                            // Vengeance mode should override goblin synergy preference.
                            if (!this.state.vengeanceMode && availableGoblins.length >= Math.min(3, this.state.teamSize)) {
                                console.log("Impossible AI: Goblin synergy found. Selecting Goblin team.");
                                this.state.player2Team = availableGoblins
                                    .sort((a,b) => getPowerScore(b) - getPowerScore(a))
                                    .slice(0, this.state.teamSize);
                            } else {
                                if (this.state.vengeanceMode) {
                                    console.log("Impossible AI: Vengeance mode overrides synergy. Building dedicated counter-team.");
                                } else {
                                    console.log("Impossible AI: No synergy found. Building counter-team.");
                                }
                                const playerWeakness = Object.keys(playerTypes).sort((a, b) => playerTypes[b] - playerTypes[a])[0];
                                const primaryCounterType = counterType[playerWeakness];

                                const counterHeroes = remainingHeroes
                                    .filter(h => h.type === primaryCounterType)
                                    .sort((a, b) => getPowerScore(b) - getPowerScore(a));

                                while (team.length < this.state.teamSize && counterHeroes.length > 0) {
                                    const hero = counterHeroes.shift();
                                    team.push(hero);
                                    pickedIds.add(hero.id);
                                }

                                if (team.length < this.state.teamSize) {
                                    console.log("Impossible AI: Filling remaining slots with best heroes.");
                                    const bestOfRest = remainingHeroes
                                        .filter(h => !pickedIds.has(h.id))
                                        .sort((a, b) => getPowerScore(b) - getPowerScore(a));

                                    while (team.length < this.state.teamSize && bestOfRest.length > 0) {
                                        team.push(bestOfRest.shift());
                                    }
                                }
                                this.state.player2Team = team;
                            }
                            console.log("Impossible AI: Team selection complete.");
                        } else { // 'normal' - AI tries to build a balanced team
                            const might = remainingHeroes.filter(h => h.type === 'Might');
                            const finesse = remainingHeroes.filter(h => h.type === 'Finesse');
                            const magic = remainingHeroes.filter(h => h.type === 'Magic');

                            // Shuffle each type pool for variety
                            for (let i = might.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[might[i], might[j]] = [might[j], might[i]]; }
                            for (let i = finesse.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[finesse[i], finesse[j]] = [finesse[j], finesse[i]]; }
                            for (let i = magic.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[magic[i], magic[j]] = [magic[j], magic[i]]; }

                            const team = [];
                            const pickedIds = new Set();

                            // Attempt to pick one of each type first if the team is not full
                            if (team.length < this.state.teamSize && might.length > 0) {
                                const hero = might.pop();
                                team.push(hero);
                                pickedIds.add(hero.id);
                            }
                            if (team.length < this.state.teamSize && finesse.length > 0) {
                                const hero = finesse.pop();
                                team.push(hero);
                                pickedIds.add(hero.id);
                            }
                            if (team.length < this.state.teamSize && magic.length > 0) {
                                const hero = magic.pop();
                                team.push(hero);
                                pickedIds.add(hero.id);
                            }

                            // Fill the rest of the team slots
                            let availablePool = remainingHeroes.filter(h => !pickedIds.has(h.id));
                            // Shuffle the remaining pool
                            for (let i = availablePool.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [availablePool[i], availablePool[j]] = [availablePool[j], availablePool[i]];
                            }

                            while (team.length < this.state.teamSize && availablePool.length > 0) {
                                team.push(availablePool.pop());
                            }

                            this.state.player2Team = team;
                        }
                    }
                }

                this.state.player2Team.forEach(hero => {
                    if (!hero.uuid) {
                        hero.uuid = this.state.nextUUID++;
                    }
                });

                this.initializeTeam(this.state.player1Team, 'player1');
                this.initializeTeam(this.state.player2Team, 'player2');

                this.state.gamePhase = 'playing';
                this.log([{ text: 'Select one of your heroes to clash.', color: COLORS.info }]);
            }

            startCampaign() {
                // Create a deep copy of the map data to modify it live
                this.state.campaignState = JSON.parse(JSON.stringify(CAMPAIGN_MAP_DATA));

                // Let's generate some starting rivals for the territories
                this.state.campaignState.nodes.forEach(node => {
                    if (node.type !== 'citadel') {
                        // Here you would call a function like generateRival()
                        // For now, we'll just assign a placeholder owner
                        node.owner = 'rival';
                    }
                });

                this.state.gamePhase = 'campaignMap';
            }

            // -----------------------------------
            //  Game Loop & Drawing
            // -----------------------------------
            gameLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }

            update() {
                const speedMultiplier = 0.4;

                if (this.state.animation) {
                    const anim = this.state.animation;
                    anim.progress += anim.speed * speedMultiplier;
                    if (anim.progress >= 1) {
                        anim.progress = 1;
                        if (anim.onComplete) anim.onComplete();
                        this.state.animation = null;
                    }
                }

                if (this.state.impactAnimation) {
                    this.state.impactAnimation.progress += 0.05 * speedMultiplier;
                    if (this.state.impactAnimation.progress >= 1) {
                        this.state.impactAnimation = null;
                    }
                }

                if (this.state.fireballAnimation) {
                    this.state.fireballAnimation.progress += 0.025 * speedMultiplier;
                    if (this.state.fireballAnimation.progress >= 1) {
                        this.state.fireballAnimation = null;
                    }
                }

                if (this.state.overloadAnimation) {
                    this.state.overloadAnimation.progress += 0.075 * speedMultiplier;
                    if (this.state.overloadAnimation.progress >= 1) {
                        this.state.overloadAnimation = null;
                    }
                }

                this.state.abilityAnimations.forEach(anim => anim.progress += anim.speed * speedMultiplier);
                this.state.abilityAnimations = this.state.abilityAnimations.filter(anim => anim.progress < 1);

                this.state.player1Team.forEach(hero => this.updateHeroAnimation(hero, speedMultiplier));
                this.state.player2Team.forEach(hero => this.updateHeroAnimation(hero, speedMultiplier));

                if (this.state.gamePhase === 'expertVictory') {
                    this.state.confettiParticles.forEach(p => {
                        p.y += p.speed;
                        p.angle += p.rotationSpeed;
                        if (p.y > this.canvas.height) {
                            p.y = -p.height;
                            p.x = Math.random() * this.canvas.width;
                        }
                    });
                }
            }

            updateHeroAnimation(hero, speedMultiplier) {
                if (hero.deathAnimation && hero.deathAnimation.progress < 1) {
                    hero.deathAnimation.progress += 0.015 * speedMultiplier;
                    if (hero.deathAnimation.progress > 1) {
                        hero.deathAnimation.progress = 1;
                    }
                }
            }

            draw() {
                this.ctx.fillStyle = COLORS.background;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                if (!this.imagesLoaded) {
                    this.ctx.fillStyle = COLORS.text;
                    this.ctx.font = `bold ${48 * this.scale}px "Cinzel"`;
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(`Loading Assets... (${this.loadedImageCount}/${this.totalImages})`, this.canvas.width / 2, this.canvas.height / 2);
                    return;
                }

                this.cardHitboxes = { player1: [], player2: [], selection: [] };
                this.campaignMapHitboxes = [];
                this.buttonHitboxes = {};

                switch(this.state.gamePhase) {
                    case 'mainMenu': this.drawMainMenuScreen(); break;
                    case 'campaignMap': this.drawCampaignMapScreen(); break;
                    case 'quickMatchSelection': this.drawQuickMatchSelectionScreen(); break;
                    case 'difficultySelection': this.drawDifficultySelectionScreen(); break;
                    case 'heroSelection': this.drawHeroSelectionScreen(); break;
                    case 'practiceSelection': this.drawPracticeSelectionScreen(); break;
                    case 'heroViewer': this.drawHeroViewerScreen(); break;
                    case 'howToPlay': this.drawHowToPlayScreen(); break;
                    case 'playing':
                    case 'bossBattle': this.drawPlayingScreen(); break;
                    case 'gameOver': this.drawGameOver(); break;
                    case 'expertVictory': this.drawExpertVictoryScreen(); break;
                }

                // Draw the tooltip last so it's on top of everything
                if (this.state.hoveredHero && (this.state.gamePhase === 'playing' || this.state.gamePhase === 'bossBattle')) {
                    this.drawHoverTooltip(this.state.hoveredHero);
                }
            }

            drawPlayingScreen() {
                this.drawTeam(this.state.player2Team, 'player2');
                this.drawTeam(this.state.player1Team, 'player1');
                this.drawBattleLog();

                this.initiateClashAnimation();
                this.drawClashButton();
                this.drawBackButton();

                if (this.state.animation && this.state.animation.type === 'clash') {
                    this.drawClashAnimation();
                }

                if (this.state.impactAnimation) this.drawImpactAnimation();
                if (this.state.fireballAnimation) this.drawFireballAnimation();
                if (this.state.overloadAnimation) this.drawOverloadAnimation();

                this.state.abilityAnimations.forEach(anim => {
                    if(anim.type === 'smokeBomb') this.drawSmokeBombAnimation(anim);
                    if(anim.type === 'longBow') this.drawLongBowAnimation(anim);
                    if(anim.type === 'ambush') this.drawAmbushAnimation(anim);
                    if(anim.type === 'lastStand') this.drawLastStandAnimation(anim);
                    if(anim.type === 'cleave') this.drawCleaveAnimation(anim);
                    if(anim.type === 'intimidation') this.drawIntimidationAnimation(anim);
                    if(anim.type === 'advantage') this.drawAdvantageIndicator(anim);
                    if(anim.type === 'bleed') this.drawBleedAnimation(anim);
                    if(anim.type === 'riposte') this.drawRiposteAnimation(anim);
                    if(anim.type === 'cardSwap') this.drawCardSwapAnimation(anim);
                    if(anim.type === 'boonOfBedlam') this.drawBoonOfBedlamAnimation(anim);
                    if(anim.type === 'galeForce') this.drawGaleForceAnimation(anim);
                });

                this.drawRoundCounter();
            }

            // -----------------------------------
            //  Drawing Helpers
            // -----------------------------------

            wrapText(text, x, y, maxWidth, lineHeight) {
                const words = text.split(' ');
                let line = '';
                this.ctx.textAlign = 'center';
                for (let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = this.ctx.measureText(testLine);
                    if (metrics.width > maxWidth && n > 0) {
                        this.ctx.fillText(line, x, y);
                        line = words[n] + ' ';
                        y += lineHeight;
                    } else {
                        line = testLine;
                    }
                }
                this.ctx.fillText(line, x, y);
            }

            drawBattleLog() {
                const logHeight = 160 * this.scale;
                const width = this.canvas.width * 0.7;
                const x = (this.canvas.width - width) / 2;
                const y = this.canvas.height - logHeight;
                const height = logHeight - (10 * this.scale);

                this.battleLogHitbox = { x, y, width, height };

                // --- Define layout constants ---
                const lineHeight = 18 * this.scale;
                const headerHeight = lineHeight * 1.5;
                const padding = 15 * this.scale;
                const scrollbarWidth = 10 * this.scale;
                const scrollbarPadding = 5 * this.scale;

                const titleYPos = y + (25 * this.scale);
                const contentX = x + padding;
                const contentY = y + (35 * this.scale);
                const contentWidth = width - (padding * 2) - scrollbarWidth - scrollbarPadding;
                const contentHeight = height - (40 * this.scale);

                // --- Calculate Content Height & Max Scroll ---
                let totalContentHeight = 0;
                const allRounds = this.state.battleLog;
                for (let i = 0; i < allRounds.length; i++) {
                    totalContentHeight += allRounds[i].length * lineHeight;
                    if (i > 0) {
                        totalContentHeight += headerHeight;
                    }
                }
                const maxScroll = Math.max(0, totalContentHeight - contentHeight);
                this.state.battleLogScrollOffset = Math.max(0, Math.min(this.state.battleLogScrollOffset, maxScroll));

                // --- Draw background and border ---
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.strokeStyle = COLORS.buttonBorder;
                this.ctx.lineWidth = 2 * this.scale;
                this.ctx.beginPath();
                this.ctx.roundRect(x, y, width, height, [15 * this.scale]);
                this.ctx.fill();
                this.ctx.stroke();

                // --- Draw Title ---
                this.ctx.fillStyle = COLORS.accent;
                this.ctx.font = `bold ${20 * this.scale}px 'Cinzel'`;
                this.ctx.textAlign = 'left';
                this.ctx.fillText('Battle Log', contentX, titleYPos);

                // --- Draw Scrollbar ---
                if (maxScroll > 0) {
                    const scrollbarX = x + width - scrollbarWidth - scrollbarPadding;
                    const scrollbarTrackY = contentY - (5 * this.scale);
                    const scrollbarTrackHeight = contentHeight + (10 * this.scale);

                    this.ctx.fillStyle = 'rgba(0,0,0,0.5)'; // Track
                    this.ctx.fillRect(scrollbarX, scrollbarTrackY, scrollbarWidth, scrollbarTrackHeight);

                    const handleHeight = Math.max(20 * this.scale, scrollbarTrackHeight * (contentHeight / totalContentHeight));
                    const scrollPercentage = this.state.battleLogScrollOffset / maxScroll;
                    const handleY = scrollbarTrackY + (1 - scrollPercentage) * (scrollbarTrackHeight - handleHeight);

                    this.ctx.fillStyle = 'rgba(255,255,255,0.5)'; // Handle
                    this.ctx.fillRect(scrollbarX, handleY, scrollbarWidth, handleHeight);
                }

                // --- Draw Log Content (Clipped) ---
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.rect(contentX - 5, contentY - 5, contentWidth + 10, contentHeight + 10);
                this.ctx.clip();

                let logY = y + height - padding + this.state.battleLogScrollOffset;
                const logsToDraw = this.state.battleLog.slice().reverse();

                for (const [roundIndex, roundLog] of logsToDraw.entries()) {
                    // Draw log entries for the current round
                    for (let i = roundLog.length - 1; i >= 0; i--) {
                        const entry = roundLog[i];
                        let currentX = contentX;
                        this.ctx.textAlign = 'left';
                        entry.forEach(part => {
                            this.ctx.fillStyle = part.color;
                            this.ctx.font = `${15 * this.scale}px 'MedievalSharp'`;
                            this.ctx.fillText(part.text, currentX, logY);
                            currentX += this.ctx.measureText(part.text).width;
                        });
                        logY -= lineHeight;
                    }

                    // Draw round header
                    const roundNumber = this.state.round - roundIndex;
                    if (roundNumber > 1) {
                        this.ctx.fillStyle = COLORS.accent;
                        this.ctx.font = `bold ${16 * this.scale}px 'Cinzel'`;
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(`--- Round ${roundNumber - 1} ---`, contentX + contentWidth / 2, logY);
                        logY -= headerHeight;
                    }
                }
                this.ctx.restore();
            }

            drawTeam(team, playerKey) {
                const isBoss = team.length === 1 && team[0].abilities;
                const cardScaleFactor = isBoss ? 1.5 : (this.state.teamSize === 5 ? 0.8 : 1);
                const cardWidth = this.baseCardWidth * this.scale * cardScaleFactor;
                const cardHeight = this.baseCardHeight * this.scale * cardScaleFactor;
                const spacing = 20 * this.scale * cardScaleFactor;
                const teamSize = team.length;
                const totalWidth = teamSize * cardWidth + (teamSize - 1) * spacing;
                const availableWidth = this.canvas.width;
                const startX = (availableWidth - totalWidth) / 2;

                const logHeight = 160 * this.scale;
                const y = playerKey === 'player1'
                    ? this.canvas.height - cardHeight - logHeight
                    : (80 * this.scale);

                const title = playerKey === 'player1' ? "Your Team" : (isBoss ? "THE MINOTAUR" : "Opponent's Team");
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = `bold ${30 * this.scale}px 'Cinzel'`;
                this.ctx.textAlign = 'center';
                this.ctx.shadowColor = 'black';
                this.ctx.shadowBlur = 5;
                this.ctx.fillText(title, startX + totalWidth / 2, y - (20 * this.scale));
                this.ctx.shadowBlur = 0;

                team.forEach((hero, index) => {
                    const x = startX + index * (cardWidth + spacing);
                    const hitbox = { x, y, width: cardWidth, height: cardHeight, hero };
                    this.cardHitboxes[playerKey].push(hitbox);
                    const isAnimating = this.state.animation?.type === 'clash' &&
                                        (this.state.animation.p1.uuid === hero.uuid || this.state.animation.p2.uuid === hero.uuid);
                    const isSwapping = this.state.abilityAnimations.some(a => a.type === 'cardSwap' && (a.hero1.uuid === hero.uuid || a.hero2.uuid === hero.uuid));

                    if (!isAnimating && !isSwapping) {
                        this.drawCard(x, y, hero, playerKey, team, cardScaleFactor);
                    }
                });
            }

            drawCard(x, y, hero, playerKey, team = [], customScale = 1) {
                this.ctx.save();

                const cardWidth = this.baseCardWidth * this.scale * customScale;
                const cardHeight = this.baseCardHeight * this.scale * customScale;
                const padding = 15 * this.scale * customScale;

                if (hero.deathAnimation) {
                    const progress = hero.deathAnimation.progress;
                    const angle = (Math.PI / 2) * progress;
                    this.ctx.translate(x + cardWidth / 2, y + cardHeight / 2);
                    this.ctx.rotate(angle);
                    this.ctx.translate(-(x + cardWidth / 2), -(y + cardHeight / 2));
                    this.ctx.globalAlpha = 1 - progress;
                }

                this.ctx.fillStyle = hero.hp > 0 ? COLORS[hero.type.toLowerCase()] : COLORS.disabled;
                this.ctx.beginPath();
                this.ctx.roundRect(x, y, cardWidth, cardHeight, [10 * this.scale * customScale]);
                this.ctx.fill();

                if (hero.hp > 0) {
                    const gradient = this.ctx.createRadialGradient(
                        x + cardWidth / 2, y + cardHeight / 2, 0,
                        x + cardWidth / 2, y + cardHeight / 2, cardWidth * 0.8
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    this.ctx.fillStyle = gradient;
                    this.ctx.fill();
                }

                let isSelected = false;
                if (this.state.gamePhase === 'heroSelection' || this.state.gamePhase === 'practiceSelection') {
                    const teamToCheck = this.state.gamePhase === 'heroSelection'
                        ? this.state.player1Team
                        : (this.state.practiceSelectionState === 'player' ? this.state.player1Team : this.state.player2Team);
                    isSelected = teamToCheck.some(h => h.id === hero.id);
                } else {
                    isSelected = (this.state.player1Selection && this.state.player1Selection.uuid === hero.uuid) ||
                                 (this.state.player2Selection && this.state.player2Selection.uuid === hero.uuid);
                }

                if (isSelected && hero.hp > 0 && playerKey !== 'tooltip') {
                    this.ctx.strokeStyle = COLORS.accent;
                    this.ctx.lineWidth = 6 * this.scale * customScale;
                    this.ctx.shadowColor = COLORS.accent;
                    this.ctx.shadowBlur = 20 * this.scale * customScale;
                } else {
                    this.ctx.strokeStyle = COLORS.cardBorder;
                    this.ctx.lineWidth = 4 * this.scale * customScale;
                }
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;

                this.ctx.globalAlpha = hero.deathAnimation ? 1 - hero.deathAnimation.progress : 1;

                this.ctx.fillStyle = COLORS.text;
                this.ctx.textAlign = 'center';
                this.ctx.font = `bold ${24 * this.scale * customScale}px 'Cinzel'`;
                this.ctx.fillText(hero.name, x + cardWidth / 2, y + padding + (10 * this.scale * customScale));

                // Draw Hero Image
                const heroImage = this.heroImages[hero.id];
                if (heroImage && heroImage.complete && heroImage.naturalHeight !== 0) {
                    const imagePadding = 20 * this.scale * customScale;
                    const imageWidth = cardWidth - imagePadding * 2;
                    const imageHeight = imageWidth; // Maintain aspect ratio
                    const imageX = x + imagePadding;
                    const imageY = y + padding + (30 * this.scale * customScale);

                    this.ctx.drawImage(heroImage, imageX, imageY, imageWidth, imageHeight);
                }

                const statY = y + cardHeight - padding - (55 * this.scale * customScale);
                const iconStatSize = 24 * this.scale * customScale;
                this.drawHeartIcon(x + padding, statY, iconStatSize, iconStatSize);
                this.drawAPSwordIcon(x + cardWidth - padding - iconStatSize, statY, iconStatSize, iconStatSize);

                const currentAP = this.getHeroCurrentAP(hero, team);
                this.ctx.font = `bold ${28 * this.scale * customScale}px 'MedievalSharp'`;
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`${hero.hp}`, x + padding + iconStatSize + (5 * this.scale * customScale), statY + iconStatSize * 0.8);
                this.ctx.textAlign = 'right';
                this.ctx.fillText(`${hero.abilityId === 'chaosBolt' ? '6-18' : currentAP}`, x + cardWidth - padding - iconStatSize - (5 * this.scale * customScale), statY + iconStatSize * 0.8);

                this.ctx.textAlign = 'center';

                // Draw Type Icon at bottom center
                const iconSize = 25 * this.scale * customScale;
                this.drawTypeIcon(hero.type, x + cardWidth / 2, statY + iconSize * 0.7, iconSize);


                this.ctx.font = `italic ${14 * this.scale * customScale}px 'MedievalSharp'`;

                let descriptionToDraw = hero.description;
                if (playerKey === 'viewer' || playerKey === 'tooltip') {
                    descriptionToDraw = hero.detailedDescription || hero.description;
                }

                // Adjust description position to be below the image area
                this.wrapText(descriptionToDraw || '', x + cardWidth / 2, y + cardHeight - (85 * this.scale * customScale), cardWidth - padding * 1.5, 15 * this.scale * customScale);


                if (hero.statusEffects && hero.statusEffects.length > 0) {
                    const bleedEffect = hero.statusEffects.find(e => e.type === 'bleed');
                    if (bleedEffect) {
                        const bleedIconX = x + cardWidth - padding - (10 * this.scale * customScale);
                        const bleedIconY = y + padding + (10 * this.scale * customScale);
                        this.ctx.fillStyle = COLORS.might;
                        this.ctx.font = `bold ${20 * this.scale * customScale}px 'MedievalSharp'`;
                        this.ctx.fillText(`🩸${bleedEffect.damage}`, bleedIconX, bleedIconY);
                    }
                }

                if (hero.hp <= 0) {
                    this.ctx.globalAlpha = hero.deathAnimation ? hero.deathAnimation.progress * 0.8 : 0.8;
                    this.drawSkullIcon(x + cardWidth / 2, y + cardHeight / 2, cardWidth * 0.5);
                }

                this.ctx.restore();
            }

            drawHoverTooltip(hoveredData) {
                const { hero } = hoveredData;
                const cardScale = 2.0;
                const cardWidth = this.baseCardWidth * this.scale * cardScale;
                const cardHeight = this.baseCardHeight * this.scale * cardScale;
                const x = (this.canvas.width - cardWidth) / 2;
                const y = (this.canvas.height - cardHeight) / 2;

                // Draw a semi-transparent overlay behind the tooltip
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.drawCard(x, y, hero, 'tooltip', [], cardScale);
            }

            drawClashAnimation() {
                const anim = this.state.animation;
                if (!anim) return;

                const { p1, p2, p1StartPos, p2StartPos } = anim;
                const cardWidth = this.baseCardWidth * this.scale;
                const cardHeight = this.baseCardHeight * this.scale;

                const p1MeetX = this.canvas.width / 2 - cardWidth;
                const p1MeetY = this.canvas.height / 2 - cardHeight / 2;
                const p2MeetX = this.canvas.width / 2;
                const p2MeetY = this.canvas.height / 2 - cardHeight / 2;

                let p1CurrentX, p1CurrentY, p2CurrentX, p2CurrentY;
                const rawProgress = anim.progress;

                if (rawProgress < 0.5) {
                    const phaseProgress = rawProgress / 0.5;
                    const easeOut = t => t * (2 - t);
                    p1CurrentX = p1StartPos.x + (p1MeetX - p1StartPos.x) * easeOut(phaseProgress);
                    p1CurrentY = p1StartPos.y + (p1MeetY - p1StartPos.y) * easeOut(phaseProgress);
                    p2CurrentX = p2StartPos.x + (p2MeetX - p2StartPos.x) * easeOut(phaseProgress);
                    p2CurrentY = p2StartPos.y + (p2MeetY - p2StartPos.y) * easeOut(phaseProgress);
                } else {
                    p1CurrentX = p1MeetX;
                    p1CurrentY = p1MeetY;
                    p2CurrentX = p2MeetX;
                    p2CurrentY = p2MeetY;

                    const lungePhaseProgress = (rawProgress - 0.5) / 0.5;
                    const lungeFactor = Math.sin(lungePhaseProgress * Math.PI);
                    const lungeDistance = 50 * this.scale * lungeFactor;

                    p1CurrentX += lungeDistance;
                    p2CurrentX -= lungeDistance;

                    if (lungePhaseProgress > 0.45 && lungePhaseProgress < 0.55 && !anim.impactTriggered) {
                        anim.impactTriggered = true;
                        this.triggerImpact();
                        this.calculateClashResult(p1, p2);
                    }
                }

                const lungeProgress = Math.max(0, (rawProgress - 0.5) / 0.5);
                const shakeAngle = Math.sin(lungeProgress * Math.PI * 4) * 0.05;

                this.ctx.save();
                this.ctx.translate(p1CurrentX + cardWidth/2, p1CurrentY + cardHeight/2);
                this.ctx.rotate(shakeAngle);
                this.drawCard(-cardWidth/2, -cardHeight/2, p1, 'player1', this.state.player1Team);
                this.ctx.restore();

                this.ctx.save();
                this.ctx.translate(p2CurrentX + cardWidth/2, p2CurrentY + cardHeight/2);
                this.ctx.rotate(-shakeAngle);
                this.drawCard(-cardWidth/2, -cardHeight/2, p2, 'player2', this.state.player2Team, this.state.gamePhase === 'bossBattle' ? 1.5 : 1);
                this.ctx.restore();
            }

            drawImpactAnimation() {
                const anim = this.state.impactAnimation;
                if (!anim) return;

                const progress = anim.progress;
                const flash = Math.sin(progress * Math.PI);

                this.ctx.save();
                this.ctx.translate(anim.x, anim.y);
                this.ctx.globalAlpha = flash;

                this.ctx.strokeStyle = 'white';
                this.ctx.lineWidth = (5 * (1 - progress)) * this.scale;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, anim.radius * progress, 0, 2 * Math.PI);
                this.ctx.stroke();

                this.ctx.strokeStyle = COLORS.accent;
                this.ctx.lineWidth = (15 * (1 - progress)) * this.scale;
                const numSpikes = 12;
                for (let i = 0; i < numSpikes; i++) {
                    const angle = (i / numSpikes) * (2 * Math.PI);
                    const startRadius = anim.radius * 0.3 * progress;
                    const endRadius = anim.radius * progress;
                    this.ctx.beginPath();
                    this.ctx.moveTo(Math.cos(angle) * startRadius, Math.sin(angle) * startRadius);
                    this.ctx.lineTo(Math.cos(angle) * endRadius, Math.sin(angle) * endRadius);
                    this.ctx.stroke();
                }
                this.ctx.restore();
            }

            drawFireballAnimation() {
                const anim = this.state.fireballAnimation;
                if (!anim) return;

                const cardWidth = this.baseCardWidth * this.scale;
                this.cardHitboxes[anim.targetTeamKey].forEach((hitbox, index) => {
                    const explosionProgress = Math.max(0, (anim.progress - (index * 0.2)) / (1 - (index * 0.2)));
                    if (explosionProgress > 0) {
                        const flash = Math.sin(explosionProgress * Math.PI);
                        const centerX = hitbox.x + cardWidth / 2;
                        const centerY = hitbox.y + hitbox.height / 2;
                        this.ctx.save();
                        this.ctx.globalAlpha = flash;
                        this.ctx.fillStyle = COLORS.accent;
                        this.ctx.beginPath();
                        this.ctx.arc(centerX, centerY, (cardWidth * 0.75) * flash, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.restore();
                    }
                });
            }

            drawOverloadAnimation() {
                const anim = this.state.overloadAnimation;
                if (!anim) return;
                const flash = Math.sin(anim.progress * Math.PI);
                this.ctx.save();
                this.ctx.strokeStyle = COLORS.accent;
                this.ctx.lineWidth = 5 * this.scale * flash;
                this.ctx.globalAlpha = flash;
                this.ctx.beginPath();
                this.ctx.moveTo(anim.startX, anim.startY);
                const dx = anim.endX - anim.startX;
                const dy = anim.endY - anim.startY;
                for (let i = 0; i < 1; i += 0.1) {
                    this.ctx.lineTo(anim.startX + dx * i + (Math.random() - 0.5) * 60 * this.scale, anim.startY + dy * i + (Math.random() - 0.5) * 60 * this.scale);
                }
                this.ctx.lineTo(anim.endX, anim.endY);
                this.ctx.stroke();
                this.ctx.restore();
            }

            drawLastStandAnimation(anim) {
                const heroBox = [...this.cardHitboxes.player1, ...this.cardHitboxes.player2].find(box => box.hero.uuid === anim.hero.uuid);
                if (!heroBox) return;
                const progress = anim.progress;
                const opacity = Math.sin(progress * Math.PI);
                const radius = heroBox.width * (1 + progress);
                this.ctx.save();
                this.ctx.globalAlpha = opacity;
                this.ctx.strokeStyle = COLORS.accent;
                this.ctx.lineWidth = 10 * this.scale * (1 - progress);
                this.ctx.beginPath();
                this.ctx.arc(heroBox.x + heroBox.width / 2, heroBox.y + heroBox.height / 2, radius, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.restore();
            }

            drawSmokeBombAnimation(anim) {
                const heroBox = [...this.cardHitboxes.player1, ...this.cardHitboxes.player2].find(box => box.hero.uuid === anim.hero.uuid);
                if (!heroBox) return;
                const progress = anim.progress;
                const opacity = Math.sin(progress * Math.PI);
                this.ctx.save();
                this.ctx.globalAlpha = opacity;
                this.ctx.fillStyle = '#aaaaaa';
                for(let i = 0; i < 5; i++) {
                    const xOffset = (Math.random() - 0.5) * heroBox.width * progress;
                    const yOffset = (Math.random() - 0.5) * heroBox.height * progress;
                    const radius = heroBox.width / 2 * (1 - progress) * (Math.random() * 0.5 + 0.5);
                    this.ctx.beginPath();
                    this.ctx.arc(heroBox.x + heroBox.width / 2 + xOffset, heroBox.y + heroBox.height / 2 + yOffset, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.restore();
            }

            drawLongBowAnimation(anim) {
                const progress = anim.progress;
                const easeOut = t => 1 - Math.pow(1 - t, 3);
                const currentX = anim.startX + (anim.endX - anim.startX) * easeOut(progress);
                const currentY = anim.startY + (anim.endY - anim.startY) * easeOut(progress);
                const angle = Math.atan2(anim.endY - anim.startY, anim.endX - anim.startX);
                this.ctx.save();
                this.ctx.translate(currentX, currentY);
                this.ctx.rotate(angle);
                this.ctx.fillStyle = COLORS.accent;
                this.ctx.strokeStyle = COLORS.buttonBorder;
                this.ctx.lineWidth = 4 * this.scale;
                this.ctx.beginPath();
                this.ctx.moveTo(20 * this.scale, 0);
                this.ctx.lineTo(-10 * this.scale, -10 * this.scale);
                this.ctx.lineTo(-10 * this.scale, 10 * this.scale);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(-10 * this.scale, 0);
                this.ctx.lineTo(-50 * this.scale, 0);
                this.ctx.stroke();
                this.ctx.restore();
            }

            drawAmbushAnimation(anim) {
                const heroBox = [...this.cardHitboxes.player1, ...this.cardHitboxes.player2].find(box => box.hero.uuid === anim.target.uuid);
                if (!heroBox) return;
                const progress = anim.progress;
                const opacity = Math.sin(progress * Math.PI);
                const length = heroBox.width * 1.5 * Math.sin(progress * Math.PI * 0.5);
                this.ctx.save();
                this.ctx.globalAlpha = opacity;
                this.ctx.strokeStyle = COLORS.might;
                this.ctx.lineWidth = 16 * this.scale;
                this.ctx.translate(heroBox.x + heroBox.width / 2, heroBox.y + heroBox.height / 2);
                this.ctx.rotate(-Math.PI / 4);
                this.ctx.beginPath();
                this.ctx.moveTo(-length / 2, 0);
                this.ctx.lineTo(length / 2, 0);
                this.ctx.stroke();
                this.ctx.restore();
            }

            drawCleaveAnimation(anim) {
                const bossBox = this.cardHitboxes.player2[0];
                if (!bossBox) return;
                const progress = anim.progress;
                const arcProgress = Math.sin(progress * Math.PI * 0.5);
                this.ctx.save();
                this.ctx.strokeStyle = COLORS.might;
                this.ctx.lineWidth = 15 * this.scale;
                this.ctx.globalAlpha = Math.sin(progress * Math.PI);
                const radius = this.canvas.width * 0.4 * arcProgress;
                this.ctx.beginPath();
                this.ctx.arc(bossBox.x + bossBox.width / 2, bossBox.y + bossBox.height / 2, radius, Math.PI * 0.7, Math.PI * 1.3);
                this.ctx.stroke();
                this.ctx.restore();
            }

            drawIntimidationAnimation(anim) {
                const bossBox = this.cardHitboxes.player2[0];
                if (!bossBox) return;
                const progress = anim.progress;
                const opacity = Math.sin(progress * Math.PI);
                const radius = bossBox.width * (0.5 + progress);
                this.ctx.save();
                this.ctx.globalAlpha = opacity * 0.5;
                this.ctx.fillStyle = '#333333';
                this.ctx.beginPath();
                this.ctx.arc(bossBox.x + bossBox.width / 2, bossBox.y + bossBox.height / 2, radius, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }

            drawAdvantageIndicator(anim) {
                const { hitbox, color } = anim;
                const progress = anim.progress;
                const opacity = Math.sin(progress * Math.PI);
                const scale = 1 + (0.5 * progress);
                this.ctx.save();
                this.ctx.globalAlpha = opacity;
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 8 * this.scale * (1 - progress);
                this.ctx.translate(hitbox.x + hitbox.width / 2, hitbox.y + hitbox.height / 2);
                this.ctx.scale(scale, scale);
                for (let i = 0; i < 3; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(-20 * this.scale, (10 - i * 15) * this.scale);
                    this.ctx.lineTo(0, (-5 - i * 15) * this.scale);
                    this.ctx.lineTo(20 * this.scale, (10 - i * 15) * this.scale);
                    this.ctx.stroke();
                }
                this.ctx.restore();
            }

            drawBleedAnimation(anim) {
                const heroBox = [...this.cardHitboxes.player1, ...this.cardHitboxes.player2].find(box => box.hero.uuid === anim.hero.uuid);
                if (!heroBox) return;
                const progress = anim.progress;
                const opacity = Math.sin(progress * Math.PI);
                this.ctx.save();
                this.ctx.globalAlpha = opacity;
                this.ctx.fillStyle = COLORS.might;
                const dropY = heroBox.y + (heroBox.height * progress);
                this.ctx.beginPath();
                this.ctx.moveTo(heroBox.x + heroBox.width / 2, dropY);
                this.ctx.quadraticCurveTo(heroBox.x + heroBox.width * 0.3, dropY + 15 * this.scale, heroBox.x + heroBox.width / 2, dropY + 30 * this.scale);
                this.ctx.quadraticCurveTo(heroBox.x + heroBox.width * 0.7, dropY + 15 * this.scale, heroBox.x + heroBox.width / 2, dropY);
                this.ctx.fill();
                this.ctx.restore();
            }

            drawRiposteAnimation(anim) {
                const progress = anim.progress;
                const opacity = Math.sin(progress * Math.PI);
                const currentX = anim.startX + (anim.endX - anim.startX) * progress;
                const currentY = anim.startY + (anim.endY - anim.startY) * progress;
                this.ctx.save();
                this.ctx.globalAlpha = opacity;
                this.ctx.strokeStyle = COLORS.accent;
                this.ctx.lineWidth = 8 * this.scale * (1 - progress);
                this.ctx.beginPath();
                this.ctx.moveTo(currentX - 20 * this.scale, currentY - 20 * this.scale);
                this.ctx.lineTo(currentX + 20 * this.scale, currentY + 20 * this.scale);
                this.ctx.moveTo(currentX + 20 * this.scale, currentY - 20 * this.scale);
                this.ctx.lineTo(currentX - 20 * this.scale, currentY + 20 * this.scale);
                this.ctx.stroke();
                this.ctx.restore();
            }

            drawCardSwapAnimation(anim) {
                const { hero1, hero2, startPos1, startPos2, progress } = anim;
                const easeInOut = t => t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
                const easedProgress = easeInOut(progress);

                const x1 = startPos1.x + (startPos2.x - startPos1.x) * easedProgress;
                const y1 = startPos1.y + (startPos2.y - startPos1.y) * easedProgress;
                const x2 = startPos2.x + (startPos1.x - startPos2.x) * easedProgress;
                const y2 = startPos2.y + (startPos1.y - startPos2.y) * easedProgress;

                const cardScaleFactor = this.state.teamSize === 5 ? 0.8 : 1;

                this.drawCard(x1, y1, hero1, 'player2', this.state.player2Team, cardScaleFactor);
                this.drawCard(x2, y2, hero2, 'player1', this.state.player1Team, cardScaleFactor);
            }

            drawBoonOfBedlamAnimation(anim) {
                const { startX, startY, endX, endY, isHeal } = anim;
                const progress = anim.progress;
                const opacity = Math.sin(progress * Math.PI);
                const currentX = startX + (endX - startX) * progress;
                const currentY = startY + (endY - startY) * progress;
                this.ctx.save();
                this.ctx.globalAlpha = opacity;
                this.ctx.fillStyle = isHeal ? '#4CAF50' : COLORS.damage;
                this.ctx.beginPath();
                this.ctx.arc(currentX, currentY, 20 * this.scale * progress, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }

            drawGaleForceAnimation(anim) {
                const { box1, box2 } = anim;
                const progress = anim.progress;
                const opacity = Math.sin(progress * Math.PI);
                this.ctx.save();
                this.ctx.globalAlpha = opacity;
                this.ctx.strokeStyle = COLORS.finesse;
                this.ctx.lineWidth = 10 * this.scale * (1 - progress);

                [box1, box2].forEach(box => {
                    const centerX = box.x + box.width / 2;
                    const centerY = box.y + box.height / 2;
                    const radius = box.width * 0.7 * progress;
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2 * progress);
                    this.ctx.stroke();
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, radius * 0.6, 0, -Math.PI * 2 * progress, true);
                    this.ctx.stroke();
                });

                this.ctx.restore();
            }

            drawButton(hitboxKey, text, colorScheme, disabled = false) {
                const hitbox = this.buttonHitboxes[hitboxKey];
                if (!hitbox) return;

                const isHovered = !disabled && this.isClickInHitbox(this.mousePos.x, this.mousePos.y, hitbox);
                let colors;
                if (disabled) {
                    colors = { start: COLORS.disabled, end: '#333333' };
                } else {
                    colors = isHovered ? COLORS.buttonHover : colorScheme;
                }

                const gradient = this.ctx.createLinearGradient(hitbox.x, hitbox.y, hitbox.x, hitbox.y + hitbox.height);
                gradient.addColorStop(0, colors.start);
                gradient.addColorStop(1, colors.end);

                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.roundRect(hitbox.x, hitbox.y, hitbox.width, hitbox.height, [10 * this.scale]);
                this.ctx.fill();
                this.ctx.strokeStyle = COLORS.buttonBorder;
                this.ctx.lineWidth = 4 * this.scale;
                this.ctx.stroke();

                this.ctx.fillStyle = disabled ? '#9E9E9E' : COLORS.text;
                this.ctx.font = `bold ${hitbox.height * 0.4}px "Cinzel"`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.shadowColor = 'black';
                this.ctx.shadowBlur = 5;
                this.ctx.fillText(text, hitbox.x + hitbox.width / 2, hitbox.y + hitbox.height / 2);
                this.ctx.shadowBlur = 0;
                this.ctx.textBaseline = 'alphabetic';
            }

            drawClashButton() {
                if (!this.state.player1Selection || this.state.isClashing || this.state.winner) return;
                const buttonWidth = 200 * this.scale;
                const buttonHeight = 60 * this.scale;
                const x = (this.canvas.width - buttonWidth) / 2;
                const y = (this.canvas.height - buttonHeight) / 2;
                this.buttonHitboxes.clash = { x, y, width: buttonWidth, height: buttonHeight };
                this.drawButton('clash', 'CLASH!', {start: COLORS.accent, end: '#B8860B'});
            }

            drawBackButton() {
                const buttonWidth = 200 * this.scale;
                const buttonHeight = 60 * this.scale;
                const x = this.canvas.width - buttonWidth - (20 * this.scale);
                const y = 20 * this.scale;
                this.buttonHitboxes.backToMenu = { x, y, width: buttonWidth, height: buttonHeight };
                this.drawButton('backToMenu', 'Main Menu', {start: COLORS.might, end: COLORS.might});
            }

            drawRoundCounter() {
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = `bold ${30 * this.scale}px "Cinzel"`;
                this.ctx.textAlign = 'center';
                this.ctx.shadowColor = 'black';
                this.ctx.shadowBlur = 5;
                const x = this.canvas.width / 2;
                this.ctx.fillText(`Round ${this.state.round}`, x, 40 * this.scale);
                this.ctx.shadowBlur = 0;
            }

            drawGameOver() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = COLORS.accent;
                this.ctx.font = `bold ${60 * this.scale}px "Cinzel"`;
                this.ctx.textAlign = 'center';
                const message = this.state.winner === 'p1' ? 'VICTORY!' : 'DEFEAT';
                this.ctx.fillText(message, this.canvas.width / 2, this.canvas.height / 2 - (100 * this.scale));
                const buttonWidth = 250 * this.scale;
                const buttonHeight = 70 * this.scale;
                const x = (this.canvas.width - buttonWidth) / 2;
                const y = this.canvas.height / 2;
                this.buttonHitboxes.playAgain = { x, y, width: buttonWidth, height: buttonHeight };
                this.drawButton('playAgain', 'Main Menu', COLORS.button);
            }

            drawExpertVictoryScreen() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.state.confettiParticles.forEach(p => {
                    this.ctx.save();
                    this.ctx.fillStyle = p.color;
                    this.ctx.translate(p.x, p.y);
                    this.ctx.rotate(p.angle);
                    this.ctx.fillRect(-p.width / 2, -p.height / 2, p.width, p.height);
                    this.ctx.restore();
                });
                this.ctx.fillStyle = COLORS.accent;
                this.ctx.shadowColor = '#000';
                this.ctx.shadowBlur = 15;
                this.ctx.font = `bold ${70 * this.scale}px "Cinzel"`;
                this.ctx.textAlign = 'center';
                this.ctx.fillText('EXPERT VICTORY!', this.canvas.width / 2, this.canvas.height / 2 - 50 * this.scale);
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = `bold ${30 * this.scale}px "MedievalSharp"`;
                this.ctx.fillText('You have mastered Trinity Clash!', this.canvas.width / 2, this.canvas.height / 2 + 20 * this.scale);
                this.ctx.shadowBlur = 0;
                const buttonWidth = 250 * this.scale;
                const buttonHeight = 70 * this.scale;
                const x = (this.canvas.width - buttonWidth) / 2;
                const y = this.canvas.height / 2 + 100 * this.scale;
                this.buttonHitboxes.playAgain = { x, y, width: buttonWidth, height: buttonHeight };
                this.drawButton('playAgain', 'Main Menu', COLORS.button);
            }

            drawMainMenuScreen() {
                // Draw the logo if it's loaded
                if (this.logoImage) {
                    const logoHeight = 200 * this.scale;
                    const logoWidth = (this.logoImage.width / this.logoImage.height) * logoHeight;
                    const x = (this.canvas.width - logoWidth) / 2;
                    // Position the logo above the center
                    const y = this.canvas.height / 2 - logoHeight - (120 * this.scale);
                    this.ctx.drawImage(this.logoImage, x, y, logoWidth, logoHeight);
                } else {
                    // Fallback to original text title if logo fails to load
                    this.ctx.fillStyle = COLORS.text;
                    this.ctx.font = `bold ${80 * this.scale}px "Cinzel"`;
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Trinity Clash', this.canvas.width / 2, this.canvas.height / 2 - 200 * this.scale);
                }

                const menuItems = [
                    { key: 'campaign', text: 'Campaign' },
                    { key: 'quickmatch', text: 'Quick Match' },
                    { key: 'heroviewer', text: 'Hero Viewer' },
                    { key: 'howtoplay', text: 'How to Play' }
                ];

                const buttonWidth = Math.min(500 * this.scale, this.canvas.width * 0.7);
                const buttonHeight = 80 * this.scale;
                const spacing = 25 * this.scale;
                const totalHeight = menuItems.length * buttonHeight + (menuItems.length - 1) * spacing;
                // Adjusted menu start Y to give the logo more space
                const menuStartY = this.canvas.height / 2 - totalHeight / 2 + 80 * this.scale;

                menuItems.forEach((item, index) => {
                    const x = (this.canvas.width - buttonWidth) / 2;
                    const y = menuStartY + index * (buttonHeight + spacing);
                    this.buttonHitboxes[item.key] = { x, y, width: buttonWidth, height: buttonHeight, disabled: item.disabled };
                    this.drawButton(item.key, item.text, COLORS.button, item.disabled);
                });
            }

            drawQuickMatchSelectionScreen() {
                this.ctx.fillStyle = COLORS.text;
                this.ctx.textAlign = 'center';
                this.ctx.font = `bold ${48 * this.scale}px "Cinzel"`;
                this.ctx.fillText('Quick Match', this.canvas.width / 2, this.canvas.height / 2 - 250 * this.scale);

                const menuItems = [
                    { key: '3v3clash', text: '3v3 Clash' },
                    { key: '5v5clash', text: '5v5 Clash' },
                    { key: 'bossbattle', text: 'Boss Battle' },
                    { key: 'practice', text: 'Practice' }
                ];

                const buttonWidth = Math.min(500 * this.scale, this.canvas.width * 0.7);
                const buttonHeight = 80 * this.scale;
                const spacing = 25 * this.scale;
                const totalHeight = menuItems.length * buttonHeight + (menuItems.length - 1) * spacing;
                const startY = (this.canvas.height - totalHeight) / 2;

                menuItems.forEach((item, index) => {
                    const x = (this.canvas.width - buttonWidth) / 2;
                    const y = startY + index * (buttonHeight + spacing);
                    this.buttonHitboxes[item.key] = { x, y, width: buttonWidth, height: buttonHeight };
                    this.drawButton(item.key, item.text, COLORS.button);
                });
                this.drawBackButton();
            }

            drawDifficultySelectionScreen() {
                this.ctx.fillStyle = COLORS.text;
                this.ctx.textAlign = 'center';
                this.ctx.font = `bold ${48 * this.scale}px "Cinzel"`;
                this.ctx.fillText('Select Difficulty', this.canvas.width / 2, this.canvas.height / 2 - 200 * this.scale);
                const difficulties = ['Easy', 'Normal', 'Expert', 'Impossible'];
                const buttonWidth = 300 * this.scale;
                const buttonHeight = 80 * this.scale;
                const spacing = 30 * this.scale;
                const totalHeight = difficulties.length * buttonHeight + (difficulties.length - 1) * spacing;
                const startY = (this.canvas.height - totalHeight) / 2;
                difficulties.forEach((level, index) => {
                    const x = (this.canvas.width - buttonWidth) / 2;
                    const y = startY + index * (buttonHeight + spacing);
                    const key = level.toLowerCase();
                    this.buttonHitboxes[key] = { x, y, width: buttonWidth, height: buttonHeight };
                    this.drawButton(key, level, COLORS.button);
                });
                this.drawBackButton();
            }

            drawHeroSelectionScreen() {
                const cardWidth = this.baseCardWidth * this.scale;
                const cardHeight = this.baseCardHeight * this.scale;
                const spacing = 20 * this.scale;
                const allHeroes = JSON.parse(JSON.stringify(HEROES));

                this.ctx.fillStyle = COLORS.text;
                this.ctx.textAlign = 'center';
                this.ctx.font = `bold ${48 * this.scale}px "Cinzel"`;
                this.ctx.fillText('Choose Your Team', this.canvas.width / 2, 80 * this.scale);
                this.ctx.font = `${24 * this.scale}px "MedievalSharp"`;
                this.ctx.fillText(`Select ${this.state.teamSize} heroes (${this.state.player1Team.length} / ${this.state.teamSize})`, this.canvas.width / 2, 130 * this.scale);
                const cardsPerRow = Math.max(1, Math.floor((this.canvas.width - spacing) / (cardWidth + spacing)));
                const numRows = Math.ceil(allHeroes.length / cardsPerRow);
                const rowSpacing = 30 * this.scale;
                const gridWidth = cardsPerRow * cardWidth + (cardsPerRow - 1) * spacing;
                const gridHeight = numRows * cardHeight + (numRows - 1) * rowSpacing;
                const startX = (this.canvas.width - gridWidth) / 2;
                const topMargin = 150 * this.scale;
                const bottomMargin = 150 * this.scale;
                const availableHeight = this.canvas.height - topMargin - bottomMargin;
                const startY = topMargin + (availableHeight - gridHeight) / 2;
                this.cardHitboxes.selection = [];
                allHeroes.forEach((hero, index) => {
                    const col = index % cardsPerRow;
                    const row = Math.floor(index / cardsPerRow);
                    const x = startX + col * (cardWidth + spacing);
                    const y = startY + row * (cardHeight + rowSpacing);
                    this.cardHitboxes.selection.push({ x, y, width: cardWidth, height: cardHeight, hero });
                    this.drawCard(x, y, hero, 'heroSelection');
                });
                if (this.state.player1Team.length === this.state.teamSize) {
                    const buttonWidth = 300 * this.scale;
                    const buttonHeight = 80 * this.scale;
                    const btnX = (this.canvas.width - buttonWidth) / 2;
                    const btnY = this.canvas.height - (150 * this.scale);
                    const buttonText = this.state.difficulty === 'boss' ? 'Face the Boss!' : 'Start Game';
                    this.buttonHitboxes.startGame = { x: btnX, y: btnY, width: buttonWidth, height: buttonHeight };
                    this.drawButton('startGame', buttonText, {start: COLORS.finesse, end: COLORS.finesse});
                }
                this.drawBackButton();
            }

            drawPracticeSelectionScreen() {
                const cardWidth = this.baseCardWidth * this.scale;
                const cardHeight = this.baseCardHeight * this.scale;
                const spacing = 20 * this.scale;
                const allHeroes = JSON.parse(JSON.stringify(HEROES));

                this.ctx.fillStyle = COLORS.text;
                this.ctx.textAlign = 'center';
                const title = this.state.practiceSelectionState === 'player' ? 'Choose Your Team' : 'Choose Opponent\'s Team';
                const team = this.state.practiceSelectionState === 'player' ? this.state.player1Team : this.state.player2Team;
                this.ctx.font = `bold ${48 * this.scale}px "Cinzel"`;
                this.ctx.fillText(title, this.canvas.width / 2, 80 * this.scale);
                this.ctx.font = `${24 * this.scale}px "MedievalSharp"`;
                this.ctx.fillText(`Select ${this.state.teamSize} heroes (${team.length} / ${this.state.teamSize})`, this.canvas.width / 2, 130 * this.scale);
                const cardsPerRow = Math.max(1, Math.floor((this.canvas.width - spacing) / (cardWidth + spacing)));
                const numRows = Math.ceil(allHeroes.length / cardsPerRow);
                const rowSpacing = 30 * this.scale;
                const gridWidth = cardsPerRow * cardWidth + (cardsPerRow - 1) * spacing;
                const gridHeight = numRows * cardHeight + (numRows - 1) * rowSpacing;
                const startX = (this.canvas.width - gridWidth) / 2;
                const topMargin = 150 * this.scale;
                const bottomMargin = 150 * this.scale;
                const availableHeight = this.canvas.height - topMargin - bottomMargin;
                const startY = topMargin + (availableHeight - gridHeight) / 2;
                this.cardHitboxes.selection = [];
                allHeroes.forEach((hero, index) => {
                    const col = index % cardsPerRow;
                    const row = Math.floor(index / cardsPerRow);
                    const x = startX + col * (cardWidth + spacing);
                    const y = startY + row * (cardHeight + rowSpacing);
                    this.cardHitboxes.selection.push({ x, y, width: cardWidth, height: cardHeight, hero });
                    this.drawCard(x, y, hero, 'practiceSelection');
                });
                if (team.length === this.state.teamSize) {
                    const buttonWidth = 300 * this.scale;
                    const buttonHeight = 80 * this.scale;
                    const btnX = (this.canvas.width - buttonWidth) / 2;
                    const btnY = this.canvas.height - (150 * this.scale);
                    const buttonText = this.state.practiceSelectionState === 'player' ? 'Confirm Your Team' : 'Start Practice';
                    this.buttonHitboxes.confirmTeam = { x: btnX, y: btnY, width: buttonWidth, height: buttonHeight };
                    this.drawButton('confirmTeam', buttonText, {start: COLORS.finesse, end: COLORS.finesse});
                }
                this.drawBackButton();
            }

            drawHeroViewerScreen() {
                const cardWidth = this.baseCardWidth * this.scale * 2;
                const cardHeight = this.baseCardHeight * this.scale * 2;
                const x = (this.canvas.width - cardWidth) / 2;
                const y = (this.canvas.height - cardHeight) / 2 - 50 * this.scale;
                const hero = HEROES[this.state.heroViewerIndex];
                this.drawCard(x, y, hero, 'viewer', [], 2);
                const buttonWidth = 200 * this.scale;
                const buttonHeight = 70 * this.scale;
                const btnY = y + cardHeight + 50 * this.scale;
                const prevX = x;
                this.buttonHitboxes.previous = { x: prevX, y: btnY, width: buttonWidth, height: buttonHeight };
                this.drawButton('previous', 'Previous', COLORS.button);
                const nextX = x + cardWidth - buttonWidth;
                this.buttonHitboxes.next = { x: nextX, y: btnY, width: buttonWidth, height: buttonHeight };
                this.drawButton('next', 'Next', COLORS.button);
                const backX = (this.canvas.width - buttonWidth) / 2;
                const backY = btnY + buttonHeight + 30 * this.scale;
                this.buttonHitboxes.back = { x: backX, y: backY, width: buttonWidth, height: buttonHeight };
                this.drawButton('back', 'Back', {start: COLORS.might, end: COLORS.might});
            }

            drawHowToPlayScreen() {
                this.ctx.fillStyle = COLORS.text;
                this.ctx.textAlign = 'center';
                this.ctx.font = `bold ${60 * this.scale}px "Cinzel"`;
                this.ctx.fillText('How to Play', this.canvas.width / 2, 120 * this.scale);

                const contentWidth = this.canvas.width * 0.6;
                const startX = (this.canvas.width - contentWidth) / 2;
                let currentY = 200 * this.scale;
                const lineHeight = 40 * this.scale;

                this.ctx.font = `bold ${32 * this.scale}px "Cinzel"`;
                this.ctx.fillStyle = COLORS.accent;
                this.ctx.fillText('The Goal', this.canvas.width / 2, currentY);
                currentY += lineHeight * 1.2;
                this.ctx.font = `${24 * this.scale}px "MedievalSharp"`;
                this.ctx.fillStyle = COLORS.text;
                this.wrapText("Defeat all of the opponent's heroes to win the clash.", this.canvas.width / 2, currentY, contentWidth, lineHeight * 0.8);
                currentY += lineHeight * 2.5;

                this.ctx.font = `bold ${32 * this.scale}px "Cinzel"`;
                this.ctx.fillStyle = COLORS.accent;
                this.ctx.fillText('Trinity Advantage', this.canvas.width / 2, currentY);
                currentY += lineHeight * 1.2;
                this.ctx.font = `${24 * this.scale}px "MedievalSharp"`;
                this.ctx.fillStyle = COLORS.text;
                this.wrapText("Each hero has a type: Might, Finesse, or Magic. Types have advantages over others, doubling your damage and halving the opponent's!", this.canvas.width / 2, currentY, contentWidth, lineHeight * 0.8);
                currentY += lineHeight * 2;

                const iconSize = 50 * this.scale;
                const iconY = currentY + iconSize / 2;
                const advantageX = this.canvas.width / 2 - 150 * this.scale;
                this.drawTypeIcon('Might', advantageX, iconY, iconSize);
                this.ctx.fillText('>', advantageX + 75 * this.scale, iconY + 15 * this.scale);
                this.drawTypeIcon('Finesse', advantageX + 150 * this.scale, iconY, iconSize);

                this.drawTypeIcon('Finesse', advantageX + 300 * this.scale, iconY, iconSize);
                this.ctx.fillText('>', advantageX + 375 * this.scale, iconY + 15 * this.scale);
                this.drawTypeIcon('Magic', advantageX + 450 * this.scale, iconY, iconSize);
                currentY += lineHeight * 2.5;

                this.drawTypeIcon('Magic', this.canvas.width / 2 - 75 * this.scale, iconY + 100 * this.scale, iconSize);
                this.ctx.fillText('>', this.canvas.width / 2, iconY + 115 * this.scale);
                this.drawTypeIcon('Might', this.canvas.width / 2 + 75 * this.scale, iconY + 100 * this.scale, iconSize);
                currentY += lineHeight * 4;

                this.ctx.font = `bold ${32 * this.scale}px "Cinzel"`;
                this.ctx.fillStyle = COLORS.accent;
                this.ctx.fillText('The Clash', this.canvas.width / 2, currentY);
                currentY += lineHeight * 1.2;
                this.ctx.font = `${24 * this.scale}px "MedievalSharp"`;
                this.ctx.fillStyle = COLORS.text;
                this.ctx.textAlign = 'left';
                this.ctx.fillText("1. Select one of your available heroes.", startX, currentY);
                currentY += lineHeight;
                this.ctx.fillText("2. Click the 'CLASH!' button to begin combat.", startX, currentY);
                currentY += lineHeight;
                this.ctx.fillText("3. Your hero will fight a hero chosen by the opponent.", startX, currentY);
                currentY += lineHeight * 2;

                const buttonWidth = 250 * this.scale;
                const buttonHeight = 70 * this.scale;
                const btnX = (this.canvas.width - buttonWidth) / 2;
                const btnY = this.canvas.height - buttonHeight - 50 * this.scale;
                this.buttonHitboxes.back = { x: btnX, y: btnY, width: buttonWidth, height: buttonHeight };
                this.drawButton('back', 'Back to Menu', {start: COLORS.might, end: COLORS.might});
            }

            drawCampaignMapScreen() {
                // For a better look, you would load a parchment image and draw it here
                // For now, a simple color will do.
                this.ctx.fillStyle = '#D2B48C'; // A parchment-like color
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                if (!this.state.campaignState) {
                    // Maybe draw a loading message or return
                    this.ctx.fillStyle = COLORS.text;
                    this.ctx.font = `bold ${48 * this.scale}px "Cinzel"`;
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Loading Campaign...', this.canvas.width / 2, this.canvas.height / 2);
                    this.drawBackButton();
                    return;
                }

                // --- 1. Draw the Connections (Paths) ---
                const nodes = this.state.campaignState.nodes;
                this.ctx.strokeStyle = '#5D4037'; // Dark brown ink color
                this.ctx.lineWidth = 3 * this.scale;
                this.ctx.setLineDash([10 * this.scale, 5 * this.scale]); // Dashed lines

                this.state.campaignState.connections.forEach(conn => {
                    const node1 = nodes.find(n => n.id === conn[0]);
                    const node2 = nodes.find(n => n.id === conn[1]);
                    if (node1 && node2) {
                        const x1 = (node1.x / 100) * this.canvas.width;
                        const y1 = (node1.y / 100) * this.canvas.height;
                        const x2 = (node2.x / 100) * this.canvas.width;
                        const y2 = (node2.y / 100) * this.canvas.height;

                        this.ctx.beginPath();
                        this.ctx.moveTo(x1, y1);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.stroke();
                    }
                });
                this.ctx.setLineDash([]); // Reset to solid lines

                // --- 2. Draw the Nodes (Territories) ---
                const nodeRadius = 30 * this.scale;
                nodes.forEach(node => {
                    const x = (node.x / 100) * this.canvas.width;
                    const y = (node.y / 100) * this.canvas.height;

                    this.campaignMapHitboxes.push({ x: x - nodeRadius, y: y - nodeRadius, width: nodeRadius * 2, height: nodeRadius * 2, node });

                    // Set color based on owner
                    let nodeColor = '#9E9E9E'; // Neutral/Gray
                    if (node.owner === 'player') nodeColor = COLORS.magic; // Player Blue
                    else if (node.owner === 'rival') nodeColor = COLORS.might; // Rival Red

                    // Draw main node circle
                    this.ctx.fillStyle = nodeColor;
                    this.ctx.strokeStyle = '#3E2723'; // Dark border
                    this.ctx.lineWidth = 4 * this.scale;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.stroke();

                    // --- 3. Handle Hover Effects ---
                    if (this.state.hoveredNode && this.state.hoveredNode.id === node.id) {
                        this.ctx.strokeStyle = COLORS.accent; // Gold highlight
                        this.ctx.lineWidth = 5 * this.scale;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, nodeRadius + 5 * this.scale, 0, Math.PI * 2);
                        this.ctx.stroke();

                        // Display node name on hover
                        this.ctx.fillStyle = COLORS.text;
                        this.ctx.font = `bold ${24 * this.scale}px "Cinzel"`;
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(node.name, x, y - nodeRadius - (15 * this.scale));
                    }

                    // --- 4. Draw Node Icon (e.g., resource type) ---
                    let icon = '';
                    if (node.resource === 'gold') icon = '💰';
                    if (node.resource === 'stone') icon = '🪨';
                    if (node.resource === 'dust') icon = '✨';
                    if (node.type === 'citadel') icon = '🏰';
                    this.ctx.font = `${30 * this.scale}px "Cinzel"`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(icon, x, y);
                    this.ctx.textBaseline = 'alphabetic'; // Reset baseline
                });

                // --- 5. Draw UI Overlays (e.g., Resource Counts) ---
                this.ctx.fillStyle = COLORS.text;
                this.ctx.font = `bold ${32 * this.scale}px "Cinzel"`;
                this.ctx.textAlign = 'left';
                // Example: this.ctx.fillText(`Gold: ${this.state.citadel.resources.gold}`, 20 * this.scale, 50 * this.scale);

                this.drawBackButton();
            }

            drawHeartIcon(x, y, width, height) {
                this.ctx.save();
                this.ctx.fillStyle = '#E53935';
                this.ctx.strokeStyle = '#C62828';
                this.ctx.lineWidth = 2 * this.scale;
                this.ctx.beginPath();
                this.ctx.moveTo(x + width / 2, y + height * 0.35);
                this.ctx.bezierCurveTo(x + width / 2, y + height * 0.1, x, y, x, y + height / 2.5);
                this.ctx.bezierCurveTo(x, y + height, x + width, y + height, x + width, y + height / 2.5);
                this.ctx.bezierCurveTo(x + width, y, x + width / 2, y + height * 0.1, x + width / 2, y + height * 0.35);
                this.ctx.fill();
                this.ctx.stroke();
                this.ctx.restore();
            }

            drawAPSwordIcon(x, y, width, height) {
                this.ctx.save();
                this.ctx.fillStyle = '#78909C';
                this.ctx.strokeStyle = '#455A64';
                this.ctx.lineWidth = 2 * this.scale;
                this.ctx.beginPath();
                this.ctx.moveTo(x + width * 0.5, y);
                this.ctx.lineTo(x + width * 0.6, y + height * 0.6);
                this.ctx.lineTo(x + width * 0.4, y + height * 0.6);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();
                this.ctx.fillStyle = '#A1887F';
                this.ctx.fillRect(x, y + height * 0.6, width, height * 0.15);
                this.ctx.strokeRect(x, y + height * 0.6, width, height * 0.15);
                this.ctx.fillRect(x + width * 0.35, y + height * 0.75, width * 0.3, height * 0.25);
                this.ctx.strokeRect(x + width * 0.35, y + height * 0.75, width * 0.3, height * 0.25);
                this.ctx.restore();
            }

            drawTypeIcon(type, x, y, size) {
                this.ctx.save();
                this.ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                this.ctx.lineWidth = size * 0.1;
                this.ctx.font = `bold ${size * 0.8}px "Cinzel"`;
                this.ctx.beginPath();
                if (type === 'Might') {
                    this.ctx.roundRect(x - size / 2, y - size / 2, size, size, size * 0.2);
                    this.ctx.stroke();
                    this.ctx.fillText('✊', x, y + size * 0.2);
                } else if (type === 'Finesse') {
                    this.ctx.ellipse(x, y, size / 2, size / 3, 0, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.fillText('🍃', x, y + size * 0.2);
                } else if (type === 'Magic') {
                    this.ctx.moveTo(x, y - size / 2);
                    this.ctx.lineTo(x + size * 0.15, y - size * 0.15);
                    this.ctx.lineTo(x + size / 2, y);
                    this.ctx.lineTo(x + size * 0.15, y + size * 0.15);
                    this.ctx.lineTo(x, y + size / 2);
                    this.ctx.lineTo(x - size * 0.15, y + size * 0.15);
                    this.ctx.lineTo(x - size / 2, y);
                    this.ctx.lineTo(x - size * 0.15, y - size * 0.15);
                    this.ctx.closePath();
                    this.ctx.stroke();
                    this.ctx.fillText('✨', x, y + size * 0.2);
                }
                this.ctx.restore();
            }

            drawSkullIcon(x, y, size) {
                this.ctx.save();
                this.ctx.fillStyle = 'rgba(20, 20, 20, 0.8)';
                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
                this.ctx.lineWidth = size * 0.05;

                // Skull
                this.ctx.beginPath();
                this.ctx.arc(x, y - size * 0.1, size * 0.25, Math.PI * 0.8, Math.PI * 2.2);
                this.ctx.lineTo(x + size * 0.15, y + size * 0.25);
                this.ctx.arc(x, y + size * 0.25, size * 0.15, 0, Math.PI);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();

                // Eyes
                this.ctx.fillStyle = '#000';
                this.ctx.beginPath();
                this.ctx.arc(x - size * 0.1, y - size * 0.15, size * 0.06, 0, Math.PI * 2);
                this.ctx.arc(x + size * 0.1, y - size * 0.15, size * 0.06, 0, Math.PI * 2);
                this.ctx.fill();

                // Crossbones
                this.ctx.save();
                this.ctx.translate(x, y + size * 0.1);
                this.ctx.rotate(Math.PI / 4);
                this.ctx.fillRect(-size * 0.3, -size * 0.05, size * 0.6, size * 0.1);
                this.ctx.strokeRect(-size * 0.3, -size * 0.05, size * 0.6, size * 0.1);
                this.ctx.rotate(Math.PI / 2);
                this.ctx.fillRect(-size * 0.3, -size * 0.05, size * 0.6, size * 0.1);
                this.ctx.strokeRect(-size * 0.3, -size * 0.05, size * 0.6, size * 0.1);
                this.ctx.restore();

                this.ctx.restore();
            }


            // -----------------------------------
            //  Game Logic
            // -----------------------------------

            log(messageParts) {
                if (this.state.battleLog.length > 0) {
                    this.state.battleLog[this.state.battleLog.length - 1].push(messageParts);
                }
            }

            processStatusEffects(team) {
                team.forEach(hero => {
                    if (hero.hp > 0 && hero.statusEffects.length > 0) {
                        const bleedEffect = hero.statusEffects.find(e => e.type === 'bleed');
                        if (bleedEffect) {
                            // Create a temporary source object for logging purposes
                            const bleedSource = { name: 'Bleed', type: 'Magic' };
                            this.dealDamage(bleedSource, hero, bleedEffect.damage, 'status');
                            this.state.abilityAnimations.push({ type: 'bleed', hero: hero, progress: 0, speed: 0.04 });
                        }

                        hero.statusEffects.forEach(effect => {
                            if (effect.duration) {
                                effect.duration--;
                            }
                        });
                        hero.statusEffects = hero.statusEffects.filter(e => !e.hasOwnProperty('duration') || e.duration > 0);
                    }
                });
            }

            startNewRound() {
                this.state.round++;
                this.state.battleLog.push([]);
                this.state.isClashing = false;
                this.state.bossActiveAbility = null;

                this.processStatusEffects(this.state.player1Team);
                this.processStatusEffects(this.state.player2Team);
                if (this.checkGameOver()) return;

                const p1Theron = this.state.player1Team.find(h => h.abilityId === 'fireball' && h.hp > 0);
                if (p1Theron && this.state.round === 5) this.handleFireball(p1Theron, this.state.player2Team, 'player2');

                const p2Theron = this.state.player2Team.find(h => h.abilityId === 'fireball' && h.hp > 0);
                if (p2Theron && this.state.round === 5) this.handleFireball(p2Theron, this.state.player1Team, 'player1');

                const p1Kaelen = this.state.player1Team.find(h => h.abilityId === 'longBow' && h.hp > 0);
                if (p1Kaelen && this.state.round % 2 === 0) this.handleLongBow(p1Kaelen, this.state.player2Team);

                const p2Kaelen = this.state.player2Team.find(h => h.abilityId === 'longBow' && h.hp > 0);
                if (p2Kaelen && this.state.round % 2 === 0) this.handleLongBow(p2Kaelen, this.state.player1Team);

                if (!this.state.winner) this.log([{ text: 'Select a hero to clash.', color: COLORS.info }]);
            }

            handleFireball(caster, targetTeam, targetTeamKey) {
                let livingTargets = targetTeam.filter(h => h.hp > 0);
                if (livingTargets.length === 0) return;

                this.log([
                    { text: caster.name, color: COLORS[caster.type.toLowerCase()] },
                    { text: ' unleashes a ', color: COLORS.text },
                    { text: 'Fireball!', color: COLORS.ability }
                ]);
                this.state.fireballAnimation = { progress: 0, targetTeamKey };

                const taunter = livingTargets.find(h => h.abilityId === 'tank' && h.hp > 0);

                if (taunter) {
                    let totalDamage = 0;
                    livingTargets.forEach(target => {
                        let damage = 5;
                        if (caster.type === 'Magic' && taunter.type === 'Might') {
                            damage *= 2;
                        }
                        totalDamage += damage;
                    });

                    if (taunter.abilityId === 'smokeBomb' && !taunter.smokeBombUsed) {
                        this.log([
                            { text: taunter.name, color: COLORS[taunter.type.toLowerCase()] },
                            { text: "'s ", color: COLORS.text },
                            { text: 'Smoke Bomb', color: COLORS.ability },
                            { text: ' evades the entire fireball!', color: COLORS.text }
                        ]);
                        taunter.smokeBombUsed = true;
                    } else {
                        // The taunter absorbs damage on behalf of all targets.
                        // We pass the first living target as the "intended" target
                        // for the dealDamage function to correctly find the taunter.
                        this.dealDamage(caster, livingTargets[0], totalDamage, 'ability');
                    }
                } else {
                    livingTargets.forEach(target => {
                        let damage = 5;
                        if(caster.type === 'Magic' && target.type === 'Might') {
                            damage *= 2;
                        }

                        if (target.abilityId === 'smokeBomb' && !target.smokeBombUsed) {
                            this.log([
                                { text: target.name, color: COLORS[target.type.toLowerCase()] },
                                { text: "'s ", color: COLORS.text },
                                { text: 'Smoke Bomb', color: COLORS.ability },
                                { text: ' evades the fireball!', color: COLORS.text }
                            ]);
                            target.smokeBombUsed = true;
                        } else {
                            this.dealDamage(caster, target, damage, 'ability');
                        }
                    });
                }
                this.checkGameOver();
            }

            handleLongBow(kaelen, targetTeam) {
                let livingTargets = targetTeam.filter(h => h.hp > 0);
                if (livingTargets.length === 0) return;

                let randomTarget = livingTargets[Math.floor(Math.random() * livingTargets.length)];
                const taunter = targetTeam.find(h => h.abilityId === 'tank' && h.hp > 0);
                let finalTarget = taunter || randomTarget;

                const kaelenBox = [...this.cardHitboxes.player1, ...this.cardHitboxes.player2].find(box => box.hero.uuid === kaelen.uuid);
                const targetBox = [...this.cardHitboxes.player1, ...this.cardHitboxes.player2].find(box => box.hero.uuid === finalTarget.uuid);

                if (kaelenBox && targetBox) {
                    this.state.abilityAnimations.push({
                        type: 'longBow', progress: 0, speed: 0.04,
                        startX: kaelenBox.x + kaelenBox.width / 2, startY: kaelenBox.y + kaelenBox.height / 2,
                        endX: targetBox.x + targetBox.width / 2, endY: targetBox.y + targetBox.height / 2,
                    });
                }
                let damage = 2;
                if (finalTarget.abilityId === 'smokeBomb' && !finalTarget.smokeBombUsed) {
                    damage = 0;
                    finalTarget.smokeBombUsed = true;
                    this.log([
                        { text: kaelen.name, color: COLORS[kaelen.type.toLowerCase()] },
                        { text: "'s arrow was dodged by ", color: COLORS.text },
                        { text: finalTarget.name, color: COLORS[finalTarget.type.toLowerCase()] },
                        { text: '!', color: COLORS.text }
                    ]);
                } else if (damage > 0) {
                    this.dealDamage(kaelen, finalTarget, damage, 'ability');
                }
                this.checkGameOver();
            }

            initiateClashAnimation() {
                if (!this.state.pendingClash) return;
                const { p1, p2 } = this.state.pendingClash;
                const p1StartPos = this.cardHitboxes.player1.find(box => box.hero.uuid === p1.uuid);
                const p2StartPos = this.cardHitboxes.player2.find(box => box.hero.uuid === p2.uuid);

                if (p1StartPos && p2StartPos) {
                    this.state.animation = {
                        type: 'clash', progress: 0, speed: 0.02, p1, p2,
                        p1StartPos: { ...p1StartPos }, p2StartPos: { ...p2StartPos },
                        impactTriggered: false,
                        onComplete: () => {
                            setTimeout(() => {
                                this.state.player1Selection = null;
                                this.state.player2Selection = null;
                                this.startNewRound();
                            }, 1000);
                        }
                    };
                    this.state.pendingClash = null;
                }
            }

            resolveClash() {
                if (!this.state.player1Selection || this.state.isClashing) return;
                let p1 = this.state.player1Selection;
                let p2;

                if (this.state.gamePhase === 'bossBattle') {
                    p2 = this.state.player2Team[0];
                    const abilities = p2.abilities;
                    let chosenAbility = null;

                    // --- Boss AI Strategic Decision ---
                    const livingPlayerHeroes = this.state.player1Team.filter(h => h.hp > 0).length;
                    const playerAttackerAP = this.getHeroCurrentAP(p1, this.state.player1Team);

                    // Simulate potential damage with Ram
                    const p1HasAdvantage = (p1.type === 'Might' && p2.type === 'Finesse') || (p1.type === 'Finesse' && p2.type === 'Magic') || (p1.type === 'Magic' && p2.type === 'Might');
                    const p2HasAdvantage = (p2.type === 'Might' && p1.type === 'Finesse') || (p2.type === 'Finesse' && p1.type === 'Magic') || (p2.type === 'Magic' && p1.type === 'Might');
                    let ramDamage = this.getHeroCurrentAP(p2, this.state.player2Team) + 5;
                    if (p2HasAdvantage) { ramDamage *= 2; }
                    if (p1HasAdvantage) { ramDamage = Math.ceil(ramDamage / 2); }

                    // Decide ability based on situation
                    if (p1.hp <= ramDamage && Math.random() < 0.8) {
                        // 80% chance to use Ram for a lethal blow
                        chosenAbility = 'ram';
                    } else if (livingPlayerHeroes >= 3 && Math.random() < 0.7) {
                        // 70% chance to Cleave when there are multiple targets
                        chosenAbility = 'cleave';
                    } else if (playerAttackerAP >= 8 && Math.random() < 0.7) {
                        // 70% chance to Intimidate a high-damage threat
                        chosenAbility = 'intimidation';
                    } else {
                        // Otherwise, pick a random ability
                        chosenAbility = abilities[Math.floor(Math.random() * abilities.length)];
                    }

                    this.state.bossActiveAbility = chosenAbility;
                    this.log([
                        { text: 'The Minotaur uses ', color: COLORS.might },
                        { text: `${this.state.bossActiveAbility.toUpperCase()}!`, color: COLORS.ability }
                    ]);
                } else {
                    let p2Team = this.state.player2Team.filter(h => h.hp > 0);
                    if (p2Team.length === 0) { this.checkGameOver(); return; }

                    if (this.state.difficulty === 'easy') {
                        // Easy AI: Still makes mistakes. Ranks moves and picks from the better half.
                        const choices = p2Team.map(opponent => {
                            const sim = this.advancedSimulateClash(p1, opponent);
                            // Simple score: damage dealt minus damage taken
                            const score = sim.p2Dealt - sim.p1Dealt;
                            return { hero: opponent, score: score };
                        });
                        choices.sort((a, b) => b.score - a.score); // Sort descending by score
                        const topHalf = choices.slice(0, Math.ceil(choices.length / 2));
                        p2 = topHalf[Math.floor(Math.random() * topHalf.length)].hero;

                    } else if (this.state.difficulty === 'normal') {
                        // Normal AI: Picks the best move based on simple damage exchange.
                        let bestChoice = null;
                        let maxScore = -Infinity;
                        p2Team.forEach(opponent => {
                            const sim = this.advancedSimulateClash(p1, opponent);
                            const score = sim.p2Dealt - sim.p1Dealt;
                            if (score > maxScore) {
                                maxScore = score;
                                bestChoice = opponent;
                            }
                        });
                        p2 = bestChoice;
                    } else if (this.state.difficulty === 'impossible') {
                        // Impossible AI: a more ruthless version of expert. No randomness.
                        // It calculates a "threat score" for each hero to make decisions.
                        const getThreatScore = (hero) => {
                            let score = hero.hp + hero.ap;
                            if (['fireball', 'tank', 'galeForce', 'soulSiphon'].includes(hero.abilityId)) {
                                score *= 1.5; // These abilities are game-changing.
                            }
                            if (hero.name.includes('Goblin')) {
                                score *= 1.2; // Goblins are part of a key synergy.
                            }
                            // Vengeance Mode: Prioritize heroes that survived the last encounter.
                            if (this.state.vengeanceMode && this.state.vengeanceSurvivors && this.state.vengeanceSurvivors.includes(hero.id)) {
                                score *= 2; // Double the threat score for survivors.
                                console.log(`Vengeance mode: ${hero.name} is a priority target (survivor).`);
                            }
                            return score;
                        };

                        console.log("Impossible AI: Starting clash resolution.");
                        let bestChoice = null;
                        let maxScore = -Infinity;

                        p2Team.forEach(opponent => {
                            const sim = this.advancedSimulateClash(p1, opponent);
                            let score = 0;
                            // Base score: net health swing, but prioritize dealing damage.
                            score += (sim.p2Dealt * 1.1) - sim.p1Dealt;

                            // Bonus for KOing the player's hero, weighted by their threat.
                            if (sim.p1FinalHp <= 0) {
                                score += 1000 + getThreatScore(p1);
                            }
                            // Penalty for losing its own hero, weighted by its value.
                            if (sim.p2FinalHp <= 0) {
                                score -= 1000 + getThreatScore(opponent);
                            }
                            // Bonus for surviving with more HP
                            score += sim.p2FinalHp - opponent.hp;

                            console.log(`Impossible AI: Simulating clash with ${opponent.name}. Score: ${score}`);
                            if (score > maxScore) {
                                maxScore = score;
                                bestChoice = opponent;
                            }
                        });

                        if (bestChoice) {
                            p2 = bestChoice;
                            console.log(`Impossible AI: Chose ${p2.name} with score ${maxScore}.`);
                        } else {
                            // This should not happen if p2Team is not empty, but as a fallback...
                            p2 = p2Team[0];
                            console.log(`Impossible AI: No best choice found, defaulting to ${p2.name}.`);
                        }

                    } else { // expert
                        // Expert AI: Uses advanced simulation and a better scoring system.
                        // It prioritizes KOs and favorable trades.
                        let bestChoice = null;
                        let maxScore = -Infinity;

                        p2Team.forEach(opponent => {
                            const sim = this.advancedSimulateClash(p1, opponent);

                            let score = 0;
                            // Base score is the net health swing.
                            // A positive score means the AI came out ahead on damage.
                            score += sim.p1Dealt - sim.p2Dealt;

                            // Huge bonus for knocking out an enemy.
                            if (sim.p1FinalHp <= 0) {
                                score += 1000;
                            }

                            // Huge penalty for losing a hero, but slightly less than the KO bonus
                            // to encourage mutual destruction over just dying.
                            if (sim.p2FinalHp <= 0) {
                                score -= 999;
                            }

                            if (score > maxScore) {
                                maxScore = score;
                                bestChoice = opponent;
                            }
                        });
                        p2 = bestChoice;
                    }
                }

                this.state.isClashing = true;

                // --- PRE-CLASH ABILITIES ---
                let madScrambleTriggered = false;
                if (p1.abilityId === 'madScramble' && p1.hp > 0) {
                    this.handleMadScramble(p1, p2);
                    madScrambleTriggered = true;
                }
                if (!madScrambleTriggered && p2.abilityId === 'madScramble' && p2.hp > 0) {
                    this.handleMadScramble(p2, p1);
                }

                if (p1.abilityId === 'galeForce' && p1.hp > 0) {
                    p2 = this.handleGaleForce(p1, p2);
                }
                if (p2.abilityId === 'galeForce' && p2.hp > 0) {
                    p1 = this.handleGaleForce(p2, p1);
                }
                this.state.player1Selection = p1;
                this.state.player2Selection = p2;

                this.log([
                    { text: p1.name, color: COLORS[p1.type.toLowerCase()] },
                    { text: ' clashes with ', color: COLORS.text },
                    { text: p2.name, color: COLORS[p2.type.toLowerCase()] },
                    { text: '!', color: COLORS.text }
                ]);

                if (this.state.gamePhase === 'bossBattle' && this.state.bossActiveAbility === 'cleave') {
                    this.state.abilityAnimations.push({ type: 'cleave', progress: 0, speed: 0.03 });
                    const playerTeam = this.state.player1Team;
                    const livingHeroes = playerTeam.filter(h => h.hp > 0);
                    const taunter = livingHeroes.find(h => h.abilityId === 'tank');

                    if (taunter) {
                        const totalDamage = livingHeroes.length * 4;
                        this.dealDamage(p2, taunter, totalDamage, 'ability');
                    } else {
                        livingHeroes.forEach(hero => {
                            this.dealDamage(p2, hero, 4, 'ability');
                        });
                    }
                } else if (this.state.gamePhase === 'bossBattle' && this.state.bossActiveAbility === 'intimidation') {
                    this.state.abilityAnimations.push({ type: 'intimidation', progress: 0, speed: 0.03 });
                } else {
                    this.state.player1Team.forEach(hero => {
                        if (hero.hp > 0 && hero.abilityId === 'ambush' && hero.uuid !== p1.uuid) {
                            this.state.abilityAnimations.push({ type: 'ambush', target: p2, progress: 0, speed: 0.05 });
                            this.dealDamage(hero, p2, 2, 'ability');
                        }
                    });
                    this.state.player2Team.forEach(hero => {
                        if (hero.hp > 0 && hero.abilityId === 'ambush' && hero.uuid !== p2.uuid) {
                            this.state.abilityAnimations.push({ type: 'ambush', target: p1, progress: 0, speed: 0.05 });
                            this.dealDamage(hero, p1, 2, 'ability');
                        }
                    });
                }

                if (this.checkGameOver()) return;
                this.state.pendingClash = { p1, p2 };
            }

            simulateClash(p1, p2) {
                let p1Damage = this.getHeroCurrentAP(p1, this.state.player1Team);
                let p2Damage = this.getHeroCurrentAP(p2, this.state.player2Team);
                const p1HasAdvantage = (p1.type === 'Might' && p2.type === 'Finesse') || (p1.type === 'Finesse' && p2.type === 'Magic') || (p1.type === 'Magic' && p2.type === 'Might');
                const p2HasAdvantage = (p2.type === 'Might' && p1.type === 'Finesse') || (p2.type === 'Finesse' && p1.type === 'Magic') || (p2.type === 'Magic' && p1.type === 'Might');
                if (p1HasAdvantage) { p1Damage *= 2; p2Damage = Math.ceil(p2Damage / 2); }
                else if (p2HasAdvantage) { p2Damage *= 2; p1Damage = Math.ceil(p1Damage / 2); }
                return [p1Damage, p2Damage];
            }

            advancedSimulateClash(p1, p2) {
                const simP1 = JSON.parse(JSON.stringify(p1));
                const simP2 = JSON.parse(JSON.stringify(p2));

                let p1Damage = this.getHeroCurrentAP(simP1, this.state.player1Team);
                let p2Damage = this.getHeroCurrentAP(simP2, this.state.player2Team);

                if (simP1.abilityId === 'opportunist' && simP2.hp < simP1.hp) { p1Damage += 3; }
                if (simP2.abilityId === 'opportunist' && simP1.hp < simP2.hp) { p2Damage += 3; }

                const p1HasAdvantage = (simP1.type === 'Might' && simP2.type === 'Finesse') || (simP1.type === 'Finesse' && simP2.type === 'Magic') || (simP1.type === 'Magic' && simP2.type === 'Might');
                const p2HasAdvantage = (simP2.type === 'Might' && simP1.type === 'Finesse') || (simP2.type === 'Finesse' && simP1.type === 'Magic') || (simP2.type === 'Magic' && simP1.type === 'Might');

                if (p1HasAdvantage) {
                    p1Damage *= 2;
                    if (simP2.abilityId !== 'chaosBolt' && simP2.abilityId !== 'crush') {
                        p2Damage = Math.ceil(p2Damage / 2);
                    }
                } else if (p2HasAdvantage) {
                    p2Damage *= 2;
                    if (simP1.abilityId !== 'chaosBolt' && simP1.abilityId !== 'crush') {
                        p1Damage = Math.ceil(p1Damage / 2);
                    }
                }

                let finalP1Damage = p1Damage;
                let finalP2Damage = p2Damage;

                if (simP1.abilityId === 'firstStrike' && finalP1Damage >= simP2.hp) {
                    finalP2Damage = 0;
                }
                if (simP2.abilityId === 'firstStrike' && finalP2Damage >= simP1.hp) {
                    finalP1Damage = 0;
                }

                if (simP1.abilityId === 'smokeBomb' && !simP1.smokeBombUsed) {
                    finalP2Damage = 0;
                }
                if (simP2.abilityId === 'smokeBomb' && !simP2.smokeBombUsed) {
                    finalP1Damage = 0;
                }

                if (simP1.abilityId === 'evasion' && !simP1.evasionUsed) {
                    finalP2Damage = 0;
                }
                if (simP2.abilityId === 'evasion' && !simP2.evasionUsed) {
                    finalP1Damage = 0;
                }

                const p1FinalHp = simP1.hp - finalP2Damage;
                const p2FinalHp = simP2.hp - finalP1Damage;

                return { p1FinalHp, p2FinalHp, p1Dealt: finalP1Damage, p2Dealt: finalP2Damage };
            }

            triggerImpact() {
                this.state.impactAnimation = { x: this.canvas.width / 2, y: this.canvas.height / 2, progress: 0, radius: 240 * this.scale };
            }

            triggerOverloadAnimation(caster, target) {
                const casterBox = [...this.cardHitboxes.player1, ...this.cardHitboxes.player2].find(box => box.hero.uuid === caster.uuid);
                const targetBox = [...this.cardHitboxes.player1, ...this.cardHitboxes.player2].find(box => box.hero.uuid === target.uuid);
                if (casterBox && targetBox) {
                    this.state.overloadAnimation = {
                        progress: 0,
                        startX: casterBox.x + this.baseCardWidth * this.scale / 2, startY: casterBox.y + this.baseCardHeight * this.scale / 2,
                        endX: targetBox.x + this.baseCardWidth * this.scale / 2, endY: targetBox.y + this.baseCardHeight * this.scale / 2,
                    };
                }
            }

            getHeroCurrentAP(hero, team) {
                if (hero.abilityId === 'chaosBolt') {
                    return Math.floor(Math.random() * 13) + 6; // 6-18 damage
                }
                let currentAP = hero.ap;
                if (hero.abilityId === 'mobRule') {
                    currentAP += team.filter(h => h.uuid !== hero.uuid && h.name.includes('Goblin') && h.hp > 0).length;
                }
                return currentAP;
            }

            dealDamage(source, target, amount, damageType = 'attack') {
                if (amount <= 0 || target.hp <= 0) return;

                const targetTeam = this.state[target.teamKey + 'Team'];
                let finalTarget = target;

                // The core of the Tank ability logic
                if (targetTeam && damageType !== 'status') { // Status effects like bleed shouldn't be taunted
                    const taunter = targetTeam.find(h => h.hp > 0 && h.abilityId === 'tank');
                    if (taunter && taunter.uuid !== target.uuid) {
                        this.log([
                            { text: taunter.name, color: COLORS[taunter.type.toLowerCase()] },
                            { text: ' absorbs the damage for ', color: COLORS.info },
                            { text: target.name, color: COLORS[target.type.toLowerCase()] },
                            { text: '!', color: COLORS.info }
                        ]);
                        finalTarget = taunter;
                    }
                }

                // Log the damage event
                const sourceColor = source.type ? COLORS[source.type.toLowerCase()] : COLORS.damage;
                this.log([
                    { text: source.name, color: sourceColor },
                    { text: ` deals ${amount} damage to `, color: COLORS.text },
                    { text: finalTarget.name, color: COLORS[finalTarget.type.toLowerCase()] },
                    { text: '!', color: COLORS.text }
                ]);

                finalTarget.hp -= amount;

                this.checkHeroKO(finalTarget);

                // Handle Riposte ability if the target survives
                if (finalTarget.hp > 0 && finalTarget.abilityId === 'riposte' && damageType === 'ability') {
                    this.handleRiposte(finalTarget, source);
                }
            }

            calculateClashResult(p1, p2) {
                let p1Damage = this.getHeroCurrentAP(p1, this.state.player1Team);
                let p2Damage = this.getHeroCurrentAP(p2, this.state.player2Team);

                if (p1.abilityId === 'opportunist' && p2.hp < p1.hp) { p1Damage += 3; }
                if (p2.abilityId === 'opportunist' && p1.hp < p2.hp) { p2Damage += 3; }

                if (this.state.gamePhase === 'bossBattle' && this.state.bossActiveAbility === 'ram') p2Damage += 5;

                const p1HasAdvantage = (p1.type === 'Might' && p2.type === 'Finesse') || (p1.type === 'Finesse' && p2.type === 'Magic') || (p1.type === 'Magic' && p2.type === 'Might');
                const p2HasAdvantage = (p2.type === 'Might' && p1.type === 'Finesse') || (p2.type === 'Finesse' && p1.type === 'Magic') || (p2.type === 'Magic' && p1.type === 'Might');

                if (p1HasAdvantage) {
                    p1Damage *= 2;
                    if (p2.abilityId !== 'chaosBolt') {
                        p2Damage = Math.ceil(p2Damage / 2);
                    }
                    this.log([{ text: p1.name, color: COLORS[p1.type.toLowerCase()] }, { text: ' has the advantage!', color: COLORS.accent }]);
                    const p1Hitbox = this.cardHitboxes.player1.find(h => h.hero.uuid === p1.uuid);
                    if(p1Hitbox) this.state.abilityAnimations.push({ type: 'advantage', hitbox: p1Hitbox, color: COLORS.accent, progress: 0, speed: 0.05 });
                } else if (p2HasAdvantage) {
                    p2Damage *= 2;
                    if (p1.abilityId !== 'chaosBolt') {
                        p1Damage = Math.ceil(p1Damage / 2);
                    }
                    this.log([{ text: p2.name, color: COLORS[p2.type.toLowerCase()] }, { text: ' has the advantage!', color: COLORS.accent }]);
                    const p2Hitbox = this.cardHitboxes.player2.find(h => h.hero.uuid === p2.uuid);
                    if(p2Hitbox) this.state.abilityAnimations.push({ type: 'advantage', hitbox: p2Hitbox, color: COLORS.accent, progress: 0, speed: 0.05 });
                }

                let p1Target = p1, p2Target = p2;
                const p1Taunter = this.state.player1Team.find(h => h.abilityId === 'tank' && h.hp > 0);
                if (p1Taunter && p1Taunter.uuid !== p1.uuid) {
                    p1Target = p1Taunter;
                    this.log([{ text: p1Taunter.name, color: COLORS[p1Taunter.type.toLowerCase()] }, { text: ' absorbs the attack!', color: COLORS.info }]);
                }
                const p2Taunter = this.state.player2Team.find(h => h.abilityId === 'tank' && h.hp > 0);
                if (p2Taunter && p2Taunter.uuid !== p2.uuid) {
                    p2Target = p2Taunter;
                    this.log([{ text: p2Taunter.name, color: COLORS[p2Taunter.type.toLowerCase()] }, { text: ' absorbs the attack!', color: COLORS.info }]);
                }

                let finalP1Damage = p1Damage, finalP2Damage = p2Damage;
                if (this.state.gamePhase === 'bossBattle' && this.state.bossActiveAbility === 'intimidation') finalP1Damage = 0;
                if (p1.abilityId === 'firstStrike' && finalP1Damage >= p2Target.hp) { finalP2Damage = 0; this.log([{ text: p1.name, color: COLORS.finesse }, { text: "'s First Strike is lethal!", color: COLORS.ability }]); }
                if (p2.abilityId === 'firstStrike' && finalP2Damage >= p1Target.hp) { finalP1Damage = 0; this.log([{ text: p2.name, color: COLORS.finesse }, { text: "'s First Strike is lethal!", color: COLORS.ability }]); }
                if (p1Target.abilityId === 'smokeBomb' && !p1Target.smokeBombUsed) { finalP2Damage = 0; p1Target.smokeBombUsed = true; this.log([{ text: p1Target.name, color: COLORS.finesse }, { text: "'s Smoke Bomb evades!", color: COLORS.ability }]); this.state.abilityAnimations.push({ type: 'smokeBomb', hero: p1Target, progress: 0, speed: 0.04 }); }
                if (p2Target.abilityId === 'smokeBomb' && !p2Target.smokeBombUsed) { finalP1Damage = 0; p2Target.smokeBombUsed = true; this.log([{ text: p2Target.name, color: COLORS.finesse }, { text: "'s Smoke Bomb evades!", color: COLORS.ability }]); this.state.abilityAnimations.push({ type: 'smokeBomb', hero: p2Target, progress: 0, speed: 0.04 }); }
                if (p1Target.abilityId === 'evasion' && !p1Target.evasionUsed) { finalP2Damage = 0; p1Target.evasionUsed = true; this.log([{ text: p1Target.name, color: COLORS.finesse }, { text: "'s Evasion allows them to dodge!", color: COLORS.ability }]); }
                if (p2Target.abilityId === 'evasion' && !p2Target.evasionUsed) { finalP1Damage = 0; p2Target.evasionUsed = true; this.log([{ text: p2Target.name, color: COLORS.finesse }, { text: "'s Evasion allows them to dodge!", color: COLORS.ability }]); }
                if (p1.abilityId !== 'crush' && p2Target.abilityId === 'sturdy') finalP1Damage = Math.max(0, finalP1Damage - 1);
                if (p2.abilityId !== 'crush' && p1Target.abilityId === 'sturdy') finalP2Damage = Math.max(0, finalP2Damage - 1);

                if (p1Target.hp <= 0) {
                    finalP1Damage = 0;
                    if (p1.hp > 0) this.log([{ text: p1.name, color: COLORS[p1.type.toLowerCase()] }, { text: "'s attack is cancelled!", color: COLORS.info }]);
                }
                if (p2Target.hp <= 0) {
                    finalP2Damage = 0;
                    if (p2.hp > 0) this.log([{ text: p2.name, color: COLORS[p2.type.toLowerCase()] }, { text: "'s attack is cancelled!", color: COLORS.info }]);
                }
                if (p1.hp <= 0) finalP1Damage = 0;
                if (p2.hp <= 0) finalP2Damage = 0;

                if(finalP2Damage > 0) { this.dealDamage(p2, p1Target, finalP2Damage, 'attack'); }
                if(finalP1Damage > 0) { this.dealDamage(p1, p2Target, finalP1Damage, 'attack'); }

                // --- Post-Clash & Campaign Logic ---
                const p2TargetDefeated = p2Target.hp <= 0;
                const p1TargetDefeated = p1Target.hp <= 0;

                if (this.state.isCampaignBattle) {
                    if (p1TargetDefeated && p2.level) { // Rival wins clash
                        this.handleRivalPromotion(p2, p1Target);
                    } else if (p2TargetDefeated) { // Player wins clash
                        const territoryId = p2.controlledTerritoryId;
                        const territory = TERRITORIES.find(t => t.territoryId === territoryId);
                        if (territory) {
                            this.collectTerritoryRewards(territory);
                        } else {
                            console.error(`Could not find territory with ID: ${territoryId}`);
                        }
                    }
                }

                // Post-clash abilities
                if (p1.abilityId === 'bleed' && finalP1Damage > 0 && p2Target.hp > 0) { this.applyBleed(p1, p2Target); }
                if (p2.abilityId === 'bleed' && finalP2Damage > 0 && p1Target.hp > 0) { this.applyBleed(p2, p1Target); }

                if (p1.abilityId === 'boonOfBedlam') { this.handleBoonOfBedlam(p1); }
                if (p2.abilityId === 'boonOfBedlam') { this.handleBoonOfBedlam(p2); }

                if (p1.abilityId === 'unstableConcoction' && p1HasAdvantage && p1.hp > 0) {
                    this.log([{ text: p1.name, color: COLORS.magic }, { text: "'s concoction explodes!", color: COLORS.ability }]);
                    this.state.player2Team.forEach(e => { if (e.hp > 0) { this.dealDamage(p1, e, 3, 'ability'); } });
                }
                if (p2.abilityId === 'unstableConcoction' && p2HasAdvantage && p2.hp > 0) {
                    this.log([{ text: p2.name, color: COLORS.magic }, { text: "'s concoction explodes!", color: COLORS.ability }]);
                    this.state.player1Team.forEach(e => { if (e.hp > 0) { this.dealDamage(p2, e, 3, 'ability'); } });
                }
                if (p1.abilityId === 'overload' && p1.hp > 0 && Math.random() < 0.5) this.handleOverload(p1, p2);
                if (p2.abilityId === 'overload' && p2.hp > 0 && Math.random() < 0.5) this.handleOverload(p2, p1);
                if (p1.abilityId === 'soulSiphon' && p2Target.hp <= 0 && p1.hp > 0 && !p1.soulSiphonUsed) {
                    const stats = HEROES.find(h => h.id === p2Target.id);
                    if (stats) { p1.hp += stats.hp; this.log([{ text: p1.name, color: COLORS.magic }, { text: ` siphons ${stats.hp} life!`, color: COLORS.ability }]); p1.soulSiphonUsed = true; }
                }
                if (p2.abilityId === 'soulSiphon' && p1Target.hp <= 0 && p2.hp > 0 && !p2.soulSiphonUsed) {
                    const stats = HEROES.find(h => h.id === p1Target.id);
                    if (stats) { p2.hp += stats.hp; this.log([{ text: p2.name, color: COLORS.magic }, { text: ` siphons ${stats.hp} life!`, color: COLORS.ability }]); p2.soulSiphonUsed = true; }
                }
                this.checkGameOver();
            }

            handleOverload(caster, originalTarget) {
                let potentialTargets = [
                    ...this.state.player1Team.filter(h => h.hp > 0 && h.uuid !== caster.uuid && h.uuid !== originalTarget.uuid),
                    ...this.state.player2Team.filter(h => h.hp > 0 && h.uuid !== caster.uuid && h.uuid !== originalTarget.uuid)
                ];
                if (potentialTargets.length > 0) {
                    const overloadTarget = potentialTargets[Math.floor(Math.random() * potentialTargets.length)];
                    this.triggerOverloadAnimation(caster, overloadTarget);
                    this.dealDamage(caster, overloadTarget, 4, 'ability');
                } else {
                    this.log([{ text: caster.name, color: COLORS.magic }, { text: "'s Overload fizzles!", color: COLORS.info }]);
                }
            }

            handleRiposte(caster, target) {
                const damage = 2;
                const casterBox = [...this.cardHitboxes.player1, ...this.cardHitboxes.player2].find(box => box.hero.uuid === caster.uuid);
                const targetBox = [...this.cardHitboxes.player1, ...this.cardHitboxes.player2].find(box => box.hero.uuid === target.uuid);
                if (casterBox && targetBox) {
                    this.state.abilityAnimations.push({
                        type: 'riposte', progress: 0, speed: 0.06,
                        startX: casterBox.x + casterBox.width / 2, startY: casterBox.y + casterBox.height / 2,
                        endX: targetBox.x + targetBox.width / 2, endY: targetBox.y + targetBox.height / 2,
                    });
                }
                this.dealDamage(caster, target, damage, 'ability');
            }

            handleMadScramble(clashingHero, opposingHero) {
                const p1Bench = this.state.player1Team.filter(h => h.hp > 0 && h.uuid !== clashingHero.uuid && h.uuid !== opposingHero.uuid);
                const p2Bench = this.state.player2Team.filter(h => h.hp > 0 && h.uuid !== clashingHero.uuid && h.uuid !== opposingHero.uuid);

                if (p1Bench.length > 0 && p2Bench.length > 0) {
                    const hero1 = p1Bench[Math.floor(Math.random() * p1Bench.length)];
                    const hero2 = p2Bench[Math.floor(Math.random() * p2Bench.length)];

                    const box1 = this.cardHitboxes.player1.find(b => b.hero.uuid === hero1.uuid);
                    const box2 = this.cardHitboxes.player2.find(b => b.hero.uuid === hero2.uuid);
                    const index1 = this.state.player1Team.findIndex(h => h.uuid === hero1.uuid);
                    const index2 = this.state.player2Team.findIndex(h => h.uuid === hero2.uuid);

                    if (!box1 || !box2 || index1 === -1 || index2 === -1) {
                        return; // Safety check
                    }

                    this.state.player1Team[index1] = hero2;
                    this.state.player2Team[index2] = hero1;

                    hero1.teamKey = 'player2';
                    hero2.teamKey = 'player1';

                    this.log([
                        { text: clashingHero.name, color: COLORS.magic },
                        { text: "'s ", color: COLORS.text },
                        { text: 'Mad Scramble', color: COLORS.ability },
                        { text: ' swaps ', color: COLORS.text },
                        { text: hero1.name, color: COLORS[hero2.type.toLowerCase()] }, // Use new team color
                        { text: ' and ', color: COLORS.text },
                        { text: hero2.name, color: COLORS[hero1.type.toLowerCase()] }, // Use new team color
                        { text: '!', color: COLORS.text }
                    ]);

                    this.state.abilityAnimations.push({
                        type: 'cardSwap',
                        hero1: hero1,
                        hero2: hero2,
                        startPos1: { x: box1.x, y: box1.y },
                        startPos2: { x: box2.x, y: box2.y },
                        progress: 0,
                        speed: 0.03
                    });

                } else {
                     this.log([
                        { text: clashingHero.name, color: COLORS.magic },
                        { text: "'s ", color: COLORS.text },
                        { text: 'Mad Scramble', color: COLORS.ability },
                        { text: ' fizzles! Not enough heroes to swap.', color: COLORS.info }
                    ]);
                }
            }

            handleBoonOfBedlam(caster) {
                const livingHeroes = [...this.state.player1Team.filter(h => h.hp > 0), ...this.state.player2Team.filter(h => h.hp > 0)];
                const otherHeroes = livingHeroes.filter(h => h.uuid !== caster.uuid);
                if (otherHeroes.length === 0) return;

                const target = otherHeroes[Math.floor(Math.random() * otherHeroes.length)];
                const isHeal = Math.random() < 0.5;

                const casterBox = [...this.cardHitboxes.player1, ...this.cardHitboxes.player2].find(box => box.hero.uuid === caster.uuid);
                const targetBox = [...this.cardHitboxes.player1, ...this.cardHitboxes.player2].find(box => box.hero.uuid === target.uuid);

                if (isHeal) {
                    target.hp = Math.min(target.maxHp, target.hp + 5);
                    this.log([
                        { text: caster.name, color: COLORS.magic },
                        { text: "'s ", color: COLORS.text },
                        { text: 'Boon of Bedlam', color: COLORS.ability },
                        { text: ' heals ', color: COLORS.text },
                        { text: target.name, color: COLORS[target.type.toLowerCase()] },
                        { text: ' for 5 HP!', color: '#4CAF50' }
                    ]);
                } else {
                    this.dealDamage(caster, target, 5, 'ability');
                }

                if (casterBox && targetBox) {
                    this.state.abilityAnimations.push({
                        type: 'boonOfBedlam', progress: 0, speed: 0.05, isHeal,
                        startX: casterBox.x + casterBox.width / 2, startY: casterBox.y + casterBox.height / 2,
                        endX: targetBox.x + targetBox.width / 2, endY: targetBox.y + targetBox.height / 2
                    });
                }
            }

            handleGaleForce(caster, originalTarget) {
                const targetTeam = this.state.player1Team.some(h => h.uuid === originalTarget.uuid) ? this.state.player1Team : this.state.player2Team;
                const livingBench = targetTeam.filter(h => h.hp > 0 && h.uuid !== originalTarget.uuid);

                if (livingBench.length > 0) {
                    const swapCandidate = livingBench[Math.floor(Math.random() * livingBench.length)];
                    const targetIndex = targetTeam.findIndex(h => h.uuid === originalTarget.uuid);
                    const swapIndex = targetTeam.findIndex(h => h.uuid === swapCandidate.uuid);

                    if (targetIndex !== -1 && swapIndex !== -1) {
                        [targetTeam[targetIndex], targetTeam[swapIndex]] = [targetTeam[swapIndex], targetTeam[targetIndex]];

                        this.log([
                            { text: caster.name, color: COLORS[caster.type.toLowerCase()] },
                            { text: "'s ", color: COLORS.text },
                            { text: 'Gale Force', color: COLORS.ability },
                            { text: ' pulls in ', color: COLORS.text },
                            { text: swapCandidate.name, color: COLORS[swapCandidate.type.toLowerCase()] },
                            { text: ' from the bench!', color: COLORS.text }
                        ]);

                        const box1 = [...this.cardHitboxes.player1, ...this.cardHitboxes.player2].find(b => b.hero.uuid === originalTarget.uuid);
                        const box2 = [...this.cardHitboxes.player1, ...this.cardHitboxes.player2].find(b => b.hero.uuid === swapCandidate.uuid);
                        if (box1 && box2) {
                            this.state.abilityAnimations.push({ type: 'galeForce', progress: 0, speed: 0.05, box1, box2 });
                        }
                        return swapCandidate;
                    }
                } else {
                    this.log([
                        { text: caster.name, color: COLORS[caster.type.toLowerCase()] },
                        { text: "'s ", color: COLORS.text },
                        { text: 'Gale Force', color: COLORS.ability },
                        { text: ' finds no one to swap with!', color: COLORS.info }
                    ]);
                }
                return originalTarget;
            }

            applyBleed(caster, target) {
                this.log([
                    { text: target.name, color: COLORS[target.type.toLowerCase()] },
                    { text: ' is now ', color: COLORS.text },
                    { text: 'Bleeding!', color: COLORS.damage }
                ]);
                let existingBleed = target.statusEffects.find(e => e.type === 'bleed');
                if (existingBleed) {
                    if (existingBleed.damage < 3) {
                        existingBleed.damage++;
                        this.log([{ text: 'Bleed has intensified!', color: COLORS.damage }]);
                    }
                } else {
                    target.statusEffects.push({ type: 'bleed', damage: 1 });
                }
            }

            checkHeroKO(hero) {
                if (hero.hp <= 0 && !hero.deathAnimation) {
                    if (hero.abilityId === 'lastStand' && !hero.lastStandUsed) {
                        hero.hp = 1;
                        hero.lastStandUsed = true;
                        this.log([{ text: hero.name, color: COLORS.might }, { text: "'s Last Stand activates!", color: COLORS.ability }]);
                        this.state.abilityAnimations.push({ type: 'lastStand', hero: hero, progress: 0, speed: 0.04 });
                    } else {
                        hero.hp = 0;
                        hero.deathAnimation = { progress: 0 };
                        this.log([{ text: hero.name, color: COLORS[hero.type.toLowerCase()] }, { text: ' has been defeated!', color: COLORS.info }]);
                    }
                }
            }

            initConfetti() {
                this.state.confettiParticles = [];
                for (let i = 0; i < 200; i++) {
                    this.state.confettiParticles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * -this.canvas.height,
                        width: 10 * this.scale * (Math.random() * 0.5 + 0.5),
                        height: 20 * this.scale * (Math.random() * 0.5 + 0.5),
                        color: [COLORS.accent, COLORS.might, COLORS.finesse, COLORS.magic][Math.floor(Math.random() * 4)],
                        speed: (Math.random() * 3 + 2) * this.scale,
                        angle: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.2
                    });
                }
            }

            checkGameOver() {
                // BUG FIX: Prevent multiple game over screens by checking if a winner is already set
                if (this.state.winner) return true;

                const p1HasHeroes = this.state.player1Team.some(h => h.hp > 0);
                const p2HasHeroes = this.state.player2Team.some(h => h.hp > 0);

                if (!p1HasHeroes) this.state.winner = 'p2';
                else if (!p2HasHeroes) this.state.winner = 'p1';

                if (this.state.winner) {
                    if (this.state.winner === 'p1' && this.state.difficulty === 'impossible') {
                        try {
                            let lossHistory = JSON.parse(localStorage.getItem('trinityClashLosses') || '[]');
                            const survivingPlayerHeroes = this.state.player1Team.filter(h => h.hp > 0).map(h => h.id);
                            const lossRecord = {
                                defeatedBy: this.state.player1Team.map(h => h.id).sort(),
                                survivors: survivingPlayerHeroes,
                                timestamp: new Date().toISOString()
                            };
                            lossHistory.push(lossRecord);
                            if (lossHistory.length > 50) {
                                lossHistory.shift();
                            }
                            localStorage.setItem('trinityClashLosses', JSON.stringify(lossHistory));
                            console.log("Impossible AI: Loss recorded to localStorage.");
                        } catch(e) {
                            console.error("Failed to save loss history.", e);
                        }
                    }
                    setTimeout(() => {
                        if (this.state.winner === 'p1' && this.state.difficulty === 'expert') {
                            this.state.gamePhase = 'expertVictory';
                            this.initConfetti();
                        } else {
                            this.state.gamePhase = 'gameOver';
                        }
                        this.log([{ text: '--- GAME OVER ---', color: COLORS.accent }]);
                        this.log([{ text: this.state.winner === 'p1' ? 'VICTORY!' : 'DEFEAT!', color: this.state.winner === 'p1' ? COLORS.accent : COLORS.damage }]);
                    }, 1000);
                    return true;
                }
                return false;
            }

            // -----------------------------------
            //  Event Handling
            // -----------------------------------
            handleCanvasClick(event) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                const backBtn = this.buttonHitboxes.backToMenu;
                if (backBtn && this.isClickInHitbox(mouseX, mouseY, backBtn)) {
                    if (this.state.gamePhase === 'quickMatchSelection') {
                        this.state.gamePhase = 'mainMenu';
                    } else {
                        this.resetGame();
                    }
                    return;
                }

                const backToMainBtn = this.buttonHitboxes.back;
                 if (backToMainBtn && this.isClickInHitbox(mouseX, mouseY, backToMainBtn)) {
                    this.state.gamePhase = 'mainMenu';
                    return;
                }

                switch (this.state.gamePhase) {
                    case 'mainMenu': this.handleMainMenuClick(mouseX, mouseY); break;
                    case 'campaignMap': this.handleCampaignMapClick(mouseX, mouseY); break;
                    case 'quickMatchSelection': this.handleQuickMatchSelectionClick(mouseX, mouseY); break;
                    case 'difficultySelection': this.handleDifficultySelectionClick(mouseX, mouseY); break;
                    case 'heroSelection': this.handleHeroSelectionClick(mouseX, mouseY); break;
                    case 'practiceSelection': this.handlePracticeSelectionClick(mouseX, mouseY); break;
                    case 'heroViewer': this.handleHeroViewerClick(mouseX, mouseY); break;
                    case 'howToPlay': this.handleHowToPlayClick(mouseX, mouseY); break;
                    case 'playing': case 'bossBattle': this.handlePlayingClick(mouseX, mouseY); break;
                    case 'gameOver': case 'expertVictory': this.handleGameOverClick(mouseX, mouseY); break;
                }
            }

            handleMouseMove(event) {
                const rect = this.canvas.getBoundingClientRect();
                this.mousePos.x = event.clientX - rect.left;
                this.mousePos.y = event.clientY - rect.top;

                // Reset hover states
                this.state.hoveredHero = null;
                this.state.hoveredNode = null;

                if (['heroSelection', 'practiceSelection', 'playing', 'bossBattle'].includes(this.state.gamePhase)) {
                    let foundHero = null;
                    const checkHitboxes = (hitboxes, team) => {
                        for (const hitbox of hitboxes) {
                            if (this.isClickInHitbox(this.mousePos.x, this.mousePos.y, hitbox)) {
                                foundHero = { ...hitbox, team };
                                break;
                            }
                        }
                    };
                    if (['heroSelection', 'practiceSelection'].includes(this.state.gamePhase)) {
                        checkHitboxes(this.cardHitboxes.selection, []);
                    } else if (['playing', 'bossBattle'].includes(this.state.gamePhase)) {
                        checkHitboxes(this.cardHitboxes.player1, this.state.player1Team);
                        if (!foundHero) checkHitboxes(this.cardHitboxes.player2, this.state.player2Team);
                    }
                    this.state.hoveredHero = foundHero;
                } else if (this.state.gamePhase === 'campaignMap') {
                    let foundNode = null;
                    for (const hitbox of this.campaignMapHitboxes) {
                        if (this.isClickInHitbox(this.mousePos.x, this.mousePos.y, hitbox)) {
                            foundNode = hitbox.node;
                            break;
                        }
                    }
                    this.state.hoveredNode = foundNode;
                }
            }

            handleMouseWheel(event) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                if (this.battleLogHitbox && this.isClickInHitbox(mouseX, mouseY, this.battleLogHitbox)) {
                    event.preventDefault();
                    this.state.battleLogScrollOffset += event.deltaY * 0.5;
                    if (this.state.battleLogScrollOffset < 0) {
                        this.state.battleLogScrollOffset = 0;
                    }
                }
            }

            handleMainMenuClick(mouseX, mouseY) {
                const campaignBtn = this.buttonHitboxes.campaign;
                if (campaignBtn && !campaignBtn.disabled && this.isClickInHitbox(mouseX, mouseY, campaignBtn)) {
                    this.startCampaign();
                    return;
                }
                const quickMatchBtn = this.buttonHitboxes.quickmatch;
                if (quickMatchBtn && !quickMatchBtn.disabled && this.isClickInHitbox(mouseX, mouseY, quickMatchBtn)) {
                    this.state.gamePhase = 'quickMatchSelection';
                    return;
                }
                const heroViewerBtn = this.buttonHitboxes.heroviewer;
                if (heroViewerBtn && !heroViewerBtn.disabled && this.isClickInHitbox(mouseX, mouseY, heroViewerBtn)) {
                    this.state.gamePhase = 'heroViewer';
                    return;
                }
                const howToPlayBtn = this.buttonHitboxes.howtoplay;
                if (howToPlayBtn && !howToPlayBtn.disabled && this.isClickInHitbox(mouseX, mouseY, howToPlayBtn)) {
                    this.state.gamePhase = 'howToPlay';
                    return;
                }
            }

            handleQuickMatchSelectionClick(mouseX, mouseY) {
                if (this.buttonHitboxes['3v3clash']?.width && this.isClickInHitbox(mouseX, mouseY, this.buttonHitboxes['3v3clash'])) { this.state.teamSize = 3; this.state.gamePhase = 'difficultySelection'; }
                if (this.buttonHitboxes['5v5clash']?.width && this.isClickInHitbox(mouseX, mouseY, this.buttonHitboxes['5v5clash'])) { this.state.teamSize = 5; this.state.gamePhase = 'difficultySelection'; }
                if (this.buttonHitboxes.bossbattle?.width && this.isClickInHitbox(mouseX, mouseY, this.buttonHitboxes.bossbattle)) { this.state.difficulty = 'boss'; this.state.teamSize = 5; this.state.gamePhase = 'heroSelection'; }
                if (this.buttonHitboxes.practice?.width && this.isClickInHitbox(mouseX, mouseY, this.buttonHitboxes.practice)) { this.state.teamSize = 3; this.state.gamePhase = 'practiceSelection'; }
            }

            handleDifficultySelectionClick(mouseX, mouseY) {
                for (const level of ['easy', 'normal', 'expert', 'impossible']) {
                    const btn = this.buttonHitboxes[level];
                    if (btn && this.isClickInHitbox(mouseX, mouseY, btn)) {
                        this.state.difficulty = level;
                        this.state.gamePhase = 'heroSelection';
                        return;
                    }
                }
            }

            handleHeroSelectionClick(mouseX, mouseY) {
                for (const hitbox of this.cardHitboxes.selection) {
                    if (this.isClickInHitbox(mouseX, mouseY, hitbox)) {
                        const hero = hitbox.hero;
                        const team = this.state.player1Team;
                        let lastIndex = -1;
                        for (let i = team.length - 1; i >= 0; i--) {
                            if (team[i].id === hero.id) {
                                lastIndex = i;
                                break;
                            }
                        }

                        if (lastIndex > -1) {
                            team.splice(lastIndex, 1);
                        } else if (team.length < this.state.teamSize) {
                            const newHero = JSON.parse(JSON.stringify(hero));
                            newHero.uuid = this.state.nextUUID++;
                            team.push(newHero);
                        }
                        return;
                    }
                }
                const startBtn = this.buttonHitboxes.startGame;
                if (startBtn && this.isClickInHitbox(mouseX, mouseY, startBtn)) {
                    if (this.state.difficulty === 'boss') this.startBossBattle();
                    else this.startGame();
                }
            }

            handlePracticeSelectionClick(mouseX, mouseY) {
                for (const hitbox of this.cardHitboxes.selection) {
                    if (this.isClickInHitbox(mouseX, mouseY, hitbox)) {
                        const hero = hitbox.hero;
                        const team = this.state.practiceSelectionState === 'player' ? this.state.player1Team : this.state.player2Team;
                        let lastIndex = -1;
                        for (let i = team.length - 1; i >= 0; i--) {
                            if (team[i].id === hero.id) {
                                lastIndex = i;
                                break;
                            }
                        }

                        if (lastIndex > -1) {
                            team.splice(lastIndex, 1);
                        } else if (team.length < this.state.teamSize) {
                            const newHero = JSON.parse(JSON.stringify(hero));
                            newHero.uuid = this.state.nextUUID++;
                            team.push(newHero);
                        }
                        return;
                    }
                }
                const confirmBtn = this.buttonHitboxes.confirmTeam;
                if (confirmBtn && this.isClickInHitbox(mouseX, mouseY, confirmBtn)) {
                    if (this.state.practiceSelectionState === 'player') this.state.practiceSelectionState = 'opponent';
                    else this.startGame(true);
                }
            }

            handleHeroViewerClick(mouseX, mouseY) {
                if (this.buttonHitboxes.previous?.width && this.isClickInHitbox(mouseX, mouseY, this.buttonHitboxes.previous)) { this.state.heroViewerIndex = (this.state.heroViewerIndex - 1 + HEROES.length) % HEROES.length; }
                if (this.buttonHitboxes.next?.width && this.isClickInHitbox(mouseX, mouseY, this.buttonHitboxes.next)) { this.state.heroViewerIndex = (this.state.heroViewerIndex + 1) % HEROES.length; }
            }

            handleHowToPlayClick(mouseX, mouseY) {
                // The generic back button is handled in handleCanvasClick now
            }

            handlePlayingClick(mouseX, mouseY) {
                if (this.state.isClashing || this.state.winner) return;

                const clashBtn = this.buttonHitboxes.clash;
                if (clashBtn && this.isClickInHitbox(mouseX, mouseY, clashBtn)) { this.resolveClash(); return; }

                for (const hitbox of this.cardHitboxes.player1) {
                    if (this.isClickInHitbox(mouseX, mouseY, hitbox) && hitbox.hero.hp > 0) {
                        this.state.player1Selection = hitbox.hero;
                        this.log([{ text: 'You selected ', color: COLORS.info }, { text: hitbox.hero.name, color: COLORS[hitbox.hero.type.toLowerCase()] }]);
                        return;
                    }
                }
            }

            handleGameOverClick(mouseX, mouseY) {
                const btn = this.buttonHitboxes.playAgain;
                if (btn && this.isClickInHitbox(mouseX, mouseY, btn)) this.resetGame();
            }

            handleCampaignMapClick(mouseX, mouseY) {
                for (const hitbox of this.campaignMapHitboxes) {
                    if (this.isClickInHitbox(mouseX, mouseY, hitbox)) {
                        const node = hitbox.node;
                        if (node.owner === 'rival') {
                            // This is where you would trigger the battle
                            alert(`You clicked on rival territory: ${node.name}! Prepare for battle!`);
                        } else if (node.owner === 'player') {
                            alert(`This is your citadel.`);
                        } else {
                            alert(`This is neutral territory: ${node.name}.`);
                        }
                        return; // Exit after handling the first clicked node
                    }
                }
            }

            isClickInHitbox(mouseX, mouseY, hitbox) {
                return mouseX >= hitbox.x && mouseX <= hitbox.x + hitbox.width &&
                       mouseY >= hitbox.y && mouseY <= hitbox.y + hitbox.height;
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                if (this.canvas.width / this.canvas.height > this.baseWidth / this.baseHeight) {
                    // Wider aspect ratio than base (e.g. ultrawide) -> scale by height
                    this.scale = this.canvas.height / this.baseHeight;
                } else {
                    // Taller or same aspect ratio (e.g. mobile portrait) -> scale by width
                    this.scale = this.canvas.width / this.baseWidth;
                }
            }
        }

        // ===================================
        //  ▶️ 3. INITIALIZE
        // ===================================
        window.onload = () => {
            const game = new Game('gameCanvas');
        };
    </script>
</body>
</html>
